# 聚合：定义受体（receptors）与受体库（repertoires）

第二个关键概念是如何定义什么是受体和受体库。当你的数据来自像 Cell Ranger 这样的 AIRR 组装工具时，你会得到许多独立的 V(D)J **链（chains）**。
但大多数问题是关于**受体（receptors）**（例如，“筛选供体 A 在第 30 天的所有受体”）或**受体库（repertoires）**（例如，“免疫治疗应答者与非应答者在基因使用方面有什么差异？”）。

换句话说，这个概念背后的假设是：*研究者在链（重排）层面工作，但在受体与受体库层面思考*。`immundata` 通过**受控聚合（controlled aggregation）**帮助你从原始链跃迁到这些更高层次的对象。也就是说，你先制定清晰的规则来说明如何把链合成为受体、再把受体合成为受体库，软件会据此执行。

## `agg_receptors()`: 定义“一个受体”的含义

使用 `immundata::agg_receptors()` 来决定在你的研究中如何构建受体，即在你的研究中*一个受体*意味着什么。

1. 先选择一个**schema（配方）**。例如：
   * 不带 V 基因片段的单链。
   * 带 V 基因片段的单链。
   * 将共享同一条形码且具有 α 与 β 位点的链配对。
   * 将每个 IGH 与具有相同 CDR3 氨基酸序列的 IGL 进行匹配。
2. 该函数会重建或**重新聚合**数据并返回一个新的 `ImmunData` 对象。底层数据不会被修改；你只是获得了一个数据的新“视图”。
3. 每个受体都会得到一个稳定的 ID，并保留到其原始链与条形码的链接。
4. 如果你之后更改了受体定义，只需重新运行此步骤即可。无需编辑基于该特定受体定义构建的其余流程。

## `agg_repertoires()`: 将受体分组成有意义的集合

使用 `immundata::agg_repertoires()` 来声明应如何把受体分组成用于分析的*受体库（repertoires）*。

* 组例：来自某一次活检的所有受体、治疗应答者的所有受体、某单细胞簇中的受体，或任意元数据列的组合。
* 结果是在物理表 `idata$repertoires` 中得到基本计数（链、条形码、唯一受体）。每个受体库都保留与其所含受体的直接链接。因此，同样，底层数据并未改变——只是其上方的轻量注释。

## 为什么这种设计有帮助

* **简单而精确：** 你可以计算度量（如 Jaccard 相似度、多样性等），而且精确的受体定义（例如 `"cdr3+v"`）会和结果一起保存，这样你可以清楚追溯当前 `ImmunData` 是在何种定义下构建的。这减少了人为失误，因为每次计算时你不需要重复输入相同的受体 schema（如 `"cdr3+v"`）。

* **内置完整的数据沿袭（data lineage）：**

  * 每个受体知道自己包含哪些链。
  * 每个受体库知道自己包含哪些受体。
  * 完整的“配方”保存在 `ImmunData` 对象的元数据中。
    六个月之后——或六位审稿人之后——你都能把任一汇总统计追溯到产生它的精确链，实现完全可复现、无隐性变换的分析流程。