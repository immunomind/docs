{"config":{"lang":["en","zh"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"\ud83d\udc26\u200d\ud83d\udd25 <code>immunomind</code> \u2013 personalize therapies using immunomics. The modern machine learning and data engineering stack for immunomics-driven development of personalized immunotherapies and vaccines <p> Tutorials   |   API reference   |   GitHub   |   Publication (coming soon...) </p> <ul> <li> <p> Installation</p> <p>Get set up fast and verify your environment.</p> <p> Start here</p> </li> <li> <p> Quick start</p> <p>Run your first analysis in 5 minutes.</p> <p> Run it here</p> </li> <li> <p> Tutorials</p> <p>Hands-on, end-to-end guides from zero to plots.</p> <p> Explore</p> </li> </ul> <p> How-tos</p> <p>Task-oriented recipes for common jobs. Under construction...</p> <ul> <li> <p> API reference \u2014 immunarch</p> <p>Multi-modal immune repertoire analytics.</p> <p> API reference</p> </li> <li> <p> API reference \u2014 immundata</p> <p>Unified layer for immune repertoire data.</p> <p> API reference</p> </li> </ul>"},{"location":"api/reference/","title":"API reference","text":"<p>All specific function details and arguments are available on the corresponding websites:</p> <ul> <li> <p> immunarch</p> <p>Multi-modal immune repertoire analytics.</p> <p> API reference</p> </li> <li> <p> immundata</p> <p>Unified data layer for immune repertoires.</p> <p> API reference</p> </li> </ul>"},{"location":"concepts/glossary/","title":"Glossary","text":""},{"location":"concepts/glossary/#cell-molecular-immunology","title":"Cell &amp; Molecular Immunology","text":"<p>TCR / BCR (noun) Protein complexes forming the T\u2011cell receptor (TCR) and B\u2011cell receptor (BCR). They recognise antigens via specific binding sites and drive downstream immune signalling. In repertoire data, TCR usually refers to TRA/TRB chains; BCR to IGH/IGK/IGL.</p> <p>Chain (noun) One polypeptide chain that is part of a receptor, for example TRA, TRB, IGH, IGK, IGL. Chains pair to form the full receptor (e.g., TRA+TRB; IGH+IGK/IGL). \u201cChain\u201d is not the same as locus (genomic location).</p> <p>V(D)J recombination (noun) Somatic DNA rearrangement in developing lymphocytes that joins V, (optionally D), and J gene segments to generate receptor diversity.</p> <p>CDR3 (AA/NT) (noun) Complementarity\u2011determining region 3, represented as amino\u2011acid (<code>cdr3_aa</code>) or nucleotide (<code>cdr3_nt</code>) sequence. CDR3 spans the V\u2011D\u2011J junction and often determines antigen specificity; it is central to clonotype definitions.</p> <p>V / J / D gene (noun) Germline gene segments that contribute to the variable region of TCR/BCR. In data tables these appear as calls such as <code>v_call</code>, <code>j_call</code>, <code>d_call</code> (possibly with allele information).</p> <p>Isotype / Class (noun) For immunoglobulins (BCR heavy chain) the constant\u2011region class: IgM, IgD, IgG, IgA, IgE. Isotype affects effector function and tissue distribution. Not applicable to TCRs.</p> <p>Somatic hypermutation (SHM) (noun) Point mutations introduced into the Ig variable region after antigen exposure, typically in germinal centres. SHM refines affinity during B\u2011cell maturation; it is not observed in TCRs.</p> <p>Class\u2011switch recombination (CSR) (noun) DNA recombination in B cells that changes the immunoglobulin heavy\u2011chain class (e.g., IgM\u2192IgG) without altering antigen specificity.</p> <p>Epitope (noun) A specific part of an antigen recognised by a receptor or antibody. Epitopes may be linear (sequence) or conformational (structure\u2011dependent).</p> <p>Antigen specificity (noun) Evidence that a receptor recognises a particular epitope or antigen; may be experimentally validated or inferred. State the evidence type when reporting.</p>"},{"location":"concepts/glossary/#airr-data-model-schemas","title":"AIRR Data Model &amp; Schemas","text":"<p>Receptor (noun) A unique receptor observation (record) in the dataset, represented by one chain pair (e.g., TRA+TRB or IGH+IGK/IGL) or a single chain when pairs are unavailable. Field: <code>imd_receptor_id</code>.</p> <p>Clonotype (noun) A group of receptors defined by an explicit rule, commonly identical CDR3 amino\u2011acid sequence together with the same V/J genes. Other rules exist (e.g., nucleotide\u2011level identity or distance\u2011based clustering); always state the rule used.</p> <p>Clone (noun; potentially ambiguous) Often used informally for clonotype or for a population of cells sharing a clonotype. Prefer clonotype unless a biological cell clone is intended; define your usage once per document.</p> <p>Repertoire (noun) All receptors for a biological or analysis unit (e.g., sample, subject, tissue, timepoint, therapy group). Repertoires are the natural level for counts, proportions, clonality and diversity. Field: <code>imd_repertoire</code>.</p> <p>Sample / Subject / Timepoint (nouns) Common metadata levels. Sample is a processed specimen; subject is the individual or organism; timepoint is the collection time or study visit. Define your usage explicitly in Methods.</p> <p>Barcode (noun) A single\u2011cell identifier used to link receptor data to transcriptomic data (Seurat/AnnData). Barcodes are case\u2011sensitive and must match the cell IDs in the external object. Field: <code>imd_barcode</code>.</p> <p>Contig (noun) An assembled VDJ sequence record reported by VDJ callers (e.g., 10x Genomics V(D)J). Contigs can be productive or non\u2011productive and may include quality metrics.</p> <p>Productive (adjective) Indicates that a contig or receptor is in\u2011frame and lacks a premature stop codon, yielding a potentially functional protein.</p> <p>Count (noun) The observed abundance of a receptor within a repertoire, often derived from UMI\u2011collapsed reads. Counts are per repertoire (the same receptor may have different counts in different repertoires). Field: <code>imd_count</code>.</p> <p>Proportion (noun) Per\u2011repertoire normalised abundance (each repertoire sums to 1). Field: <code>imd_proportion</code>.</p> <p>Receptor ID (noun) A unique identifier used to join tables (e.g., linking annotations to counts). May be a hash of key sequence fields or an explicit ID column.</p> <p>AIRR format (noun) The community standard for AIRR data representation and metadata. Field names and semantics are defined by the AIRR Community; using the standard improves tool interoperability.</p> <p>Schema (noun) A mapping that tells <code>ImmunData</code> which columns in the annotations represent the receptor, repertoire, barcode, and other key fields (e.g., <code>schema_receptor</code>). Schemas make code portable across datasets with different column names.</p> <p>Aggregation / <code>agg_repertoires()</code> (noun/verb) The process of building repertoire\u2011level tables from receptor annotations using a chosen grouping (sample, tissue, etc.). Aggregation locks the analysis unit so that counts and proportions are well defined.</p> <p>Snapshot / Immutability (noun) Saving the current state of an <code>ImmunData</code> object to disk after expensive steps (e.g., annotations). Snapshots avoid repeating prior work, improve reproducibility, and speed up iteration.</p>"},{"location":"concepts/glossary/#analytics-metrics","title":"Analytics &amp; Metrics","text":"<p>Gene usage (noun) The frequency distribution of V, J and (where applicable) D gene calls within a repertoire or cohort. Often used to compare immunological states or technical batches.</p> <p>Clonality (noun) The degree to which a repertoire is dominated by a small number of receptors. In <code>immunarch</code>, clonality can be summarised by proportion bins (e.g., Hyperexpanded, Large, \u2026) or by rank bins (e.g., top\u201110, top\u2011100). Both views highlight overabundance, but from different angles.</p> <p>Rank\u2011abundance line (noun) Curve within a repertoire that orders receptors by abundance (count or proportion) and plots abundance vs rank to show dominance and tail behaviour.</p> <p>D50 / DXX (noun) The minimal number of top receptors required to accumulate X% of a repertoire\u2019s total abundance (e.g., D50 for 50%). Lower values indicate stronger dominance by high\u2011abundance receptors.</p> <p>Diversity indices (noun) Quantitative measures of repertoire diversity, such as Shannon entropy, Simpson index, and Hill numbers. Each index emphasises richness vs evenness differently; specify the index and base when reporting.</p> <p>Evenness (Pielou) (noun) A normalised measure of how evenly abundance is distributed among receptors, derived from Shannon entropy. High evenness means similar abundances; low evenness indicates dominance.</p> <p>Overlap (noun) Similarity between repertoires (e.g., Jaccard, Morisita\u2013Horn). Always state the matching rule (e.g., clonotype definition) and the index used.</p> <p>Public clonotype / Publicity (noun) A clonotype observed in multiple individuals. Publicity can be defined by simple presence across subjects or by quantitative measures (e.g., Jaccard across repertoires). Define the criterion used.</p> <p>Convergent recombination (Convergence) (noun) Independent nucleotide sequences that encode the same amino\u2011acid receptor sequence (often the same CDR3 AA), suggesting selection or recombination bias.</p> <p>Motif (noun) A recurring sequence pattern, such as a k\u2011mer, regular expression, or GLIPH\u2011like motif, that may correlate with specificity or structure.</p> <p>Convergence score (noun) Numeric measure of sequence\u2011level convergence (methods vary; report the definition with the score).</p>"},{"location":"concepts/glossary/#workflows-visualisation","title":"Workflows &amp; Visualisation","text":"<p>QC / Filtering (noun) Initial checks and thresholds applied before analysis (e.g., removing non\u2011productive contigs, extreme lengths, low\u2011quality calls). Good QC prevents bias downstream.</p> <p>Normalisation (noun) Scaling within each repertoire so that abundances are comparable (e.g., converting counts to proportions). Always state the rule used and whether additional scaling was applied.</p> <p>Subsampling / Rarefaction (noun) Downsampling to a common depth for fair comparisons; report the target depth and random seed when relevant.</p> <p>UMAP / t\u2011SNE / PCA (noun) Dimensionality\u2011reduction methods used to embed high\u2011dimensional features (e.g., sequence embeddings) for visualisation. Choice of method and parameters can affect apparent structure.</p> <p>Feature table (noun) A tabular matrix of engineered features for ML/DL (e.g., V/J one\u2011hots, k\u2011mer counts, CDR3 embeddings). Feature tables can be exported to Parquet for cross\u2011language training.</p> <p>Embedding (noun) A continuous vector representation of sequences or cells (e.g., CDR3 embedding) used for similarity search, clustering, or downstream prediction.</p>"},{"location":"concepts/glossary/#tooling-infrastructure","title":"Tooling &amp; Infrastructure","text":"<p>ImmunData (proper noun) An R6 data container that stores receptor\u2011level annotations and repertoire\u2011level summaries using schemas aligned with AIRR. It supports lazy operations, rapid aggregation, and snapshotting.</p> <p><code>annotate_*</code> (family) Functions that add columns to <code>ImmunData</code> (e.g., clonality labels, meta\u2011annotations). They preserve the original data and extend it with new fields.</p> <p><code>airr_*</code> (family) Functions that compute repertoire\u2011level statistics and summaries (e.g., clonality, diversity, overlap) from an <code>ImmunData</code> object.</p> <p><code>receptor_*</code> (family) Functions that filter or transform receptors (rows) within <code>ImmunData</code> (e.g., select chains, length ranges, or productivity).</p> <p><code>annotate_seurat()</code> (function) A helper that copies selected columns from <code>ImmunData</code> to a Seurat object using <code>barcode</code> as the join key, enabling UMAP colouring by receptor labels.</p> <p>Arrow / Parquet (proper nouns) Columnar storage formats used on disk. They support efficient compression, fast column access, and interoperability across languages.</p> <p>DuckDB / duckplyr / dbplyr (proper nouns) An embedded analytical database (DuckDB) and R packages that translate tidy verbs to SQL (<code>duckplyr</code>, <code>dbplyr</code>). They enable lazy execution and scale beyond RAM.</p> <p>Lazy evaluation (noun) A computation model where operations are recorded but not executed until needed. It reduces memory pressure and allows the backend to optimise query plans.</p> <p>Materialise / <code>compute()</code> / <code>collect()</code> (verbs/functions) Materialise means persist results. <code>compute()</code> creates a (temporary) table inside DuckDB; <code>collect()</code> pulls the result into R memory as a data frame.</p> <p>Registry (noun) A mechanism in <code>immunarch</code> for registering method implementations so families like <code>airr_*</code> can expose multiple named strategies under one interface.</p>"},{"location":"concepts/basics/aggregation/","title":"Aggregation: defining receptors and repertoires","text":"<p>The second key concept is about defining what receptors and repertoires are. When your data come out of an AIRR assembly tool like Cell Ranger, you get many separate V(D)J chains. But most questions are about receptors (e.g., \"filter all receptors from donor A on day 30\") or repertoires (e.g., \"what is the difference in terms of gene usage between responders and non-responders to immunotherapy?\").</p> <p>In other words, the underlying assumption of the second concept is researchers work with chains (rearrangements) but think in receptors and repertoires. <code>immundata</code> helps you move from raw chains to these higher-level objects using controlled aggregation. This means you set clear rules for how to combine chains to receptors, and receptors \u2013 to repertoires, and the software applies those rules.</p>"},{"location":"concepts/basics/aggregation/#agg_receptors-define-what-one-receptor-means","title":"<code>agg_receptors()</code>: define what \"one receptor\" means","text":"<p>Use <code>immundata::agg_receptors()</code> to decide how to build a receptor in your study, what one receptor means in your study.</p> <ol> <li>You start by choosing a schema (a recipe). Examples:</li> <li>Single chain without a V gene segment.</li> <li>Single chain with a V gene segment.</li> <li>Pair chains that share the same barcode and have \u03b1 and \u03b2 loci.</li> <li>Match each IGH with the IGL that has the same CDR3 amino-acid sequence.</li> <li>The function rebuilds or re-aggregates the data and returns a new <code>ImmunData</code> object. The underlying data is not changed. You just get a new \"view\" into the data.</li> <li>Each receptor gets a stable ID and keeps links to its original chains and barcode.</li> <li>If you change your receptor definition later, you can just rerun this step. You do not need to edit the rest of your pipeline that was built on the specific receptor definition.</li> </ol>"},{"location":"concepts/basics/aggregation/#agg_repertoires-group-receptors-into-meaningful-sets","title":"<code>agg_repertoires()</code>: group receptors into meaningful sets","text":"<p>Use <code>immundata::agg_repertoires()</code> to say how receptors should be grouped for analysis to repertoires.</p> <ul> <li>Example groups: all receptors from one biopsy, from responders to therapy, from a single-cell cluster, or any mix of metadata columns.</li> <li>The result is a physical table <code>idata$repertoires</code> with basic counts (chains, barcodes, unique receptors). Each repertoire keeps direct links to the receptors it contains. So, again, no underlying data is changed \u2014 only light-weight annotations on top of it.</li> </ul>"},{"location":"concepts/basics/aggregation/#why-this-design-helps","title":"Why this design helps","text":"<ul> <li> <p>Easy and precise: you can compute metrics (Jaccard similarity, diversity, etc.) and the exact receptor definition (for example, <code>\"cdr3+v\"</code>) is saved with the result as you can clearly trace back to what definition you used in building the current <code>ImmunData</code>. This reduces human-made mistakes, as you don't need to input the same receptor schema <code>\"cdr3+v\"</code> each time you compute something.</p> </li> <li> <p>Full data lineage by design:</p> </li> <li> <p>Every receptor knows which chains it includes.</p> </li> <li>Every repertoire knows which receptors it includes.</li> <li>The full \"recipe\" is stored in the <code>ImmunData</code> object metadata.     Six months later \u2013 or six reviewers later \u2013 you can trace any summary statistic back to the precise chains that produced it, enabling fully reproducible pipelines with no hidden transformations.</li> </ul>"},{"location":"concepts/basics/data_units/","title":"Units: chain -&gt; barcode -&gt; receptor","text":"<p>The first key concept is about basic units of data operations. These units are:</p> <ul> <li> <p>Chain is a single V(D)J sequence record (read/contig/molecule), e.g., TRA, TRB, IGH, or IGL with V(D)J gene and any other information, including gene expression and immunogenicity. This is a minimally possible data unit, a building block of everything. It is the smallest sequence-level unit and remains immutable after ingest so you can always drill down to its exact nucleotide/amino-acid sequence and annotations.</p> </li> <li> <p>Barcode is a physical container that can hold 0, 1, or multiple chains.</p> <ul> <li>Single-cell: a droplet/cell barcode.</li> <li>Spatial: a spot barcode (may capture transcripts from multiple cells).</li> <li>Bulk: the term \u201cbarcode\u201d is not used, effectively making each chain a separate \"barcode\".</li> </ul> <p>It is a biological unit that \"stores\" relevant biological data and is used for aggregation of same chains and computing counts of same receptors coming from different barcodes.</p> </li> <li> <p>Receptor is a logical grouping of chains that represents one biological receptor instance used for downstream analysis and reporting. All immune repertoire statistics or receptor tracking is computed on receptors. It is defined by a user-specified receptor schema consisting of:</p> <ul> <li>Receptor features: typically CDR3 amino-acid (AA) sequence, optionally combined with V gene (and, if desired, J gene or length).</li> <li>Receptor chains: e.g., single chain, \u03b1+\u03b2 (TCR), heavy+light (BCR), or other well-defined groupings. In multi-chain cases (e.g., dual-\u03b1), specify your pairing/merging rules.</li> </ul> </li> </ul> <p>To summarise: chains are how <code>immundata</code> stores the information, barcodes bundle chains together, and receptors are the minimal units on which repertoire statistics are computed.</p> Term In plain English How immundata represents it Role Chain A single V(D)J transcript (e.g. TRA or IGH) coming from one read or contig. One row in the physical table <code>idata$annotations</code>; retains <code>locus</code>, <code>cdr3</code>, <code>umis</code>/<code>reads</code> and other crucial rearrangement characteristics. Raw data unit \u2013 atomic building block. Barcode / Cell The droplet (10x), spot (Visium) or well a chain was captured in. Column <code>imd_barcode</code>. Physical bundle \u2013 groups chains that share a capture compartment. Receptor The biological receptor you analyse: a single chain or a paired set (\u03b1\u03b2, Heavy-Light) from one cell. Virtual table <code>idata$receptors</code>; unique ID <code>imd_receptor_id</code>. Logical unit \u2013 minimal object for AIRR statistics. Repertoire A set of receptors grouped by sample, donor, cluster, etc. Physical table <code>idata$repertoires</code>; unique ID <code>imd_repertoire_id</code>; grouping columns you choose. Aggregate unit \u2013 higher-level grouping for comparative analysis."},{"location":"concepts/basics/immutability/","title":"Pipeline-based execution: immutability and materialisation","text":"<p>We talked a lot about data traceability or data lineage in the first two concepts. But it makes sense to implement the data lineage only if every workflow step is re-playable. Or, as we call it, reproducible. To make results reproducible, every analysis step must be easy to run again without any side effects, when the underlying data is changed. In <code>immundata</code>-powered pipelines, an analysis is a pipeline of immutable transformations:</p> <ul> <li>Each function returns a new <code>ImmunData</code> object.</li> <li>The underlying data is not changed. New object \u2013 new view into the data.</li> <li>The chain of <code>ImmunData</code> objects records how data moved from raw chains to final numbers.</li> </ul>"},{"location":"concepts/basics/immutability/#on-disk-by-default-in-memory-only-when-needed","title":"On-disk by default, in-memory only when needed","text":"<p>Immutability is not very convenient at the first glance, but it allows us to work with larger-than-RAM immune repertoire datasets. There are several smart data engineering techniques <code>immundata</code> employs:</p> <ul> <li>Immune data tables are saved on disk as Parquet files (a column-compressed format, meaning faster data analysis).</li> <li>Dataset is materialised (i.e., loaded into RAM) only when a calculation needs them. For example, to compute a subset or to output final metrics like overlap indices.</li> <li>For medium data (e.g., ~10 GB), this feels \"invisible\": DuckDB (the lightweight database <code>immundata</code> uses as a backend) streams from the file and gives you a normal in-memory frame.</li> <li>And for large data (e.g., ~100 GB), the same code still works because the whole magic with Parquet and views into the data allows DuckDB to efficiently query the underlying data without loading unnecessary parts to RAM.</li> </ul> <p>A trade-off is clear: you either work in RAM like you did with typical data frames, with RAM being your limiting factor; or you create immutable transformations, allowing DuckDB to optimize processing queries, leading to the out-of-memory data support.</p>"},{"location":"concepts/basics/immutability/#what-pipeline-thinking-means-day-to-day","title":"What \"pipeline thinking\" means day to day","text":"<p>Thinking in immutable pipelines means two things:</p> <ul> <li> <p>Create snapshots: when you hit an expensive step, create and save an intermediate <code>ImmunData</code> object using <code>immundata::write_immundata()</code> function. The function will create a new <code>ImmunData</code> object, and you can use this new object, gaining huge speed-ups. Example: computing edit distances to patterns or sequences. If you create a snapshot after that, the distances are saved on disk. If you don't, <code>immundata</code> will need to re-compute distances each time you call a transformation or computation on <code>ImmunData</code> you are working with, and you know how long distance computations are.</p> </li> <li> <p>Assume re-execution: Anyone, including your colleague or even future-you on a bigger machine, should be able to run <code>pipeline.R</code> end-to-end and get the exact same result.</p> </li> </ul>"},{"location":"concepts/basics/immutability/#for-developers-hide-the-plumbing-and-let-users-focus-on-biology","title":"For developers: hide the plumbing and let users focus on biology","text":"<p>Packages that use <code>immundata</code> should expose simple, high-level functions like <code>compute_diversity()</code> or <code>plot_overlap()</code>. Users should not need to think about <code>ImmunData</code>, DuckDB, or Parquet. Ideally, they never notice there is an on-disk database at all.</p> <p>Leave the data engineering to the data engineers (and bioinformaticians). Keep your attention on the biology \u2014 it\u2019s complex enough already.</p>"},{"location":"concepts/basics/overview/","title":"Overview","text":"<p>By design, <code>immundata</code> splits the analysis workflow into two clear phases:</p> <ol> <li> <p>Ingestion \u2013 convert your AIRR files into a special format saved on disk, and then read them to a tidy <code>ImmunData</code> object.</p> </li> <li> <p>Transformation  \u2013 explore, annotate, filter and compute on that object.</p> </li> </ol> <p>Before we go into more details for each of the phase, there are three straightforward yet essential concepts to keep in mind:</p> <ol> <li> <p>Data units.</p> </li> <li> <p>Aggregation of receptors and repertoires.</p> </li> <li> <p>Pipeline-based execution.</p> </li> </ol> <p>These concepts set it apart from data-frame-based AIRR libraries. By extension, the concepts affect how you would work with and even think about the data analysis in other packages such as <code>immunarch</code> which use <code>immundata</code> as a backbone for computations.</p>"},{"location":"concepts/workflow/phase_ingestion/","title":"Phase 1: Ingestion","text":"<pre><code>      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 files \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2502\n          \u25bc\n   read_metadata()    \u2500\u2500\u2500\u2500 Read metadata\n          \u2502\n          \u25bc \n  read_repertoires()  \u2500\u2500\u252c\u2500 Read repertoire files (!)\n          \u2502             \u2502      \u25bc\n          \u2502             \u2502  Preprocess\n          \u2502             \u2502      \u25bc\n          \u2502             \u2502  Aggregate receptors (!)\n          \u2502             \u2502      \u25bc\n          \u2502             \u2502  Postprocess\n          \u2502             \u2502      \u25bc\n          \u2502             \u2502  Aggregate repertoires #1\n          \u2502             \u2502      \u25bc\n          \u2502             \u2514\u2500 Write data on disk (!)\n          \u25bc\n   agg_repertoires()  \u2500\u2500\u2500\u2500 Aggregate repertoires #2\n          \u2502\n          \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 ImmunData \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Steps marked with <code>(!)</code> are non-optional.</p> <p>The goal of the ingestion phase is to turn a folder of AIRR-seq files into an immutable on-disk <code>ImmunData</code> dataset.</p> <ol> <li> <p>Read metadata:</p> <p><code>read_metadata()</code> pulls in any sample- or donor-level information, such as therapy arm, HLA type, age, etc., and stores it in a data frame that we can pass to the main reading functions <code>read_repertoires</code>. Attaching this context early means every chain you read later already \"knows\" which patient or time-point it belongs to.</p> <p>You can safely skip it if you don't have per-sample pr per-donor metadata.</p> </li> <li> <p>Read repertoire files:</p> <p><code>read_repertoires()</code> streams Parquet/CSV/TSV files straight into DuckDB that powers <code>ImmunData</code> objects.</p> </li> <li> <p>Preprocess:</p> <p>During the read step you may pass a <code>preproc = recipe</code> argument to <code>read_repertoires</code> to preprocess data before aggregating receptors: drop unused columns, strip non-productive sequences, translate field names to the AIRR schema, de-duplicate contigs, etc. Because this logic is declarative, re-runs produce identical results.</p> </li> <li> <p>Aggregate receptors:</p> <p>Receptor schema is how you define a receptor \u2013 a logical unit of analysis. The <code>read_repertoires</code> collapses chains into receptors accordingly and assigns each a stable unique identifier.</p> </li> <li> <p>Postprocess:</p> <p>A mirror step to preprocess: a convenient hook to run QC checks, add derived fields, attach reference-gene annotations, or compute per-chain quality metrics after the dataset is ready. You can pass any number of steps which will be executed in a sequential order.</p> </li> <li> <p>Aggregate repertoires #1:</p> <p>If you already know how to group chains into receptors, perhaps by <code>\"Sample\"</code> or <code>\"Donor\"</code> columns from the metadata, you can pass <code>repertoire_schema = c(\"Sample\")</code> to <code>read_repertoires()</code>. Otherwise, skip and define repertoires later (common in single-cell workflows where you need cluster labels first).</p> </li> <li> <p>Write data on disk:</p> <p><code>read_repertoires</code> always persists what it just built: column-compressed Parquet parts plus a human-readable metadata in JSON. From here on, downstream steps can reopen the dataset instantly without touching the raw AIRR files again.</p> </li> <li> <p>Aggregate repertoires #2:</p> <p>Call <code>agg_repertoires()</code> later if you withheld grouping until additional annotations were available, e.g. donor + cell cluster.</p> </li> </ol>"},{"location":"concepts/workflow/phase_transformation/","title":"Phase 2: Transformation","text":"<pre><code>      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 ImmunData \u2502       \u2502 AnnData / Seurat / TCRdist \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502 seur@meta.data / adata.obs \u2502\n            \u2502             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2502                             \u2502\n            \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2502\n            \u25bc\n   annotate_immundata()    \u2500\u2500\u2500\u2500 Import external annotations to ImmunData\n            \u2502\n            \u25bc \n     agg_repertoires()     \u2500\u2500\u2500\u2500 Aggregate repertoires\n            \u2502\n            \u25bc \n    filter_immundata()     \u2500\u2500\u2500\u2500 Filter receptors or repertoires\n            \u2502\n            \u25bc \n    mutate_immundata()     \u2500\u2500\u2500\u2500 Create or modify columns, compute statistics\n            \u2502\n            \u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u251c\u2500\u2500\u2500\u2500\u25ba\u2502 save / plot #1 \u2502\n            \u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u25bc \n   annotate_immundata()    \u2500\u2500\u2500\u2500 Annotate ImmunData with the computed statistics\n            \u2502\n            \u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u251c\u2500\u2500\u2500\u2500\u25ba\u2502 save / plot #2 \u2502\n            \u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2502\n            \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502seur@meta.data[:] &lt;- ...\u2502 \u2500\u2500\u2500\u2500 Export ImmunData annotations\n\u2502    adata.obs = ...     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Transformation is a loop of annotation \u2192 modification and computation \u2192 visualisation, always producing a new <code>ImmunData</code> while leaving the parent intact. That immutability is what turns every notebook into a reproducible pipeline.</p> <ol> <li> <p>Import external annotations to ImmunData:</p> <p><code>annotate_immundata()</code> (or its thin wrappers <code>annotate_barcodes()</code> / <code>annotate_receptors()</code>) merges labels from Seurat/AnnData/TCRdist/anything that can be expressed as a keyed data frame to the main table, so each chain has a corresponding annotation.</p> </li> <li> <p>Aggregate repertoires:</p> <p>Now that extra labels are present, you might regroup receptors, for example, by donor \u00d7 cell-state.</p> </li> <li> <p>Filter receptors or repertoires:</p> <p><code>filter_immundata()</code> accepts tidy-verse predicates on chains, receptors, or repertoires.</p> </li> <li> <p>Create or modify columns, compute statistics:</p> <p>On this step, you compute statistics per-repertoire or per-receptor, using input receptor features. There are several scenarios depending on what you try to achieve.</p> <p>1) use <code>immunarch</code> for the most common analysis functions. The package will automatically annotate both receptors/barcodes/chains (!) and repertoires (!!) if it is possible;</p> <p>2) simply mutate on the whole dataset using <code>dplyr</code> syntax, like compute edit distance to a specific pattern using <code>mutate_immundata</code>;</p> <p>3) more complex compute that requires a function to apply to values and is probably not supported by <code>duckplyr</code>.</p> </li> <li> <p>Save / plot #1:</p> <p>Cache the <code>ImmunData</code>. Use <code>ggplot2</code> to visualise the statistics, computed from <code>ImmunData</code>.</p> </li> <li> <p>Annotate ImmunData with the computed statistics:</p> <p><code>annotate_immundata()</code> (again) joins the freshly minted statistics back to the canonical dataset.</p> </li> <li> <p>Save / plot #2:</p> <p>Save the <code>ImmunData</code> with new annotations to disk. Plot the results of analysis.</p> </li> <li> <p>Export ImmunData annotations:</p> <p>Write the annotated data back to the cell-level dataset (Seurat / AnnData) for the subsequent analysis. Additionally, you could write the <code>ImmunData</code> itself to disk if needed.</p> </li> </ol>"},{"location":"guides/data_schema/","title":"<code>ImmunData</code> structure","text":"<p>This page defines the internal tables and standard column names used inside an <code>ImmunData</code> object. These names are stable across functions in <code>immundata</code> and packages, which depend on it, such as <code>immunarch</code>.</p> <p>Important: You rarely need to touch internal tables directly. Treat them as managed by <code>immundata</code>. Direct edits can break referential integrity and invalidate results. Prefer high-level functions and accessors, supplied by packages.</p> <p>The column names can be accessed or retrieved programmatically via their names directly, e.g., <code>imd_&lt;key&gt;</code>, or via aliases <code>immundata::imd_schema(\"&lt;key&gt;\")</code>. </p>"},{"location":"guides/data_schema/#core-tables","title":"Core tables","text":"<ul> <li>Annotations (<code>idata$annotations</code>): the physical, barcode-level table that stores chain/rearrangement records plus per-barcode (cell/spot) metadata. One or more chains may belong to the same barcode. Stored on the disk in Parquet files and in DuckDB.</li> <li>Receptors (<code>idata$receptors</code>): a virtual (computed) view that returns receptor-level rows according to the active receptor schema (e.g., single chain, \u03b1\u03b2 TCR, heavy+light BCR). Each receptor keeps links back to its source barcode(s)/chain(s). </li> <li>Repertoires (<code>idata$repertoires</code>): a physical table with repertoire IDs and basic counts created by <code>agg_repertoires()</code> (e.g., group by sample, donor, condition). <code>idata$metadata</code> uses this table to show the sample-level information.</li> </ul> <p>Hierarchically, chains \u2192 barcodes \u2192 receptors \u2192 repertoires are the building blocks. <code>immundata</code> keeps full lineage between them. </p>"},{"location":"guides/data_schema/#canonical-column-names","title":"Canonical column names","text":"<p>Reminder: use canonical column names such as <code>imd_count</code> in exploratory scripts and notebooks. Use keys with <code>imd_schema()</code> for packages.</p> <p>These are the standardized names <code>imd_schema()</code> returns and that functions expect across the stack.</p> Key (for <code>imd_schema()</code>) Canonical column Core table Meaning <code>\"receptor\"</code> <code>imd_receptor_id</code> receptors/annotations Stable receptor identifier. <code>\"barcode\"</code> / <code>\"cell\"</code> <code>imd_barcode</code> annotations Barcode (cell/spot) identifier. <code>\"chain\"</code> <code>imd_chain_id</code> annotations Unique chain/rearrangement identifier. <code>\"repertoire\"</code> <code>imd_repertoire_id</code> repertoires/annotations Repertoire (group) identifier. <code>\"count\"</code> / <code>\"receptor_count\"</code> <code>imd_count</code> receptors/repertoires Count of receptors per group (semantics depend on context). <code>\"chain_count\"</code> <code>imd_n_chains</code> annotations/receptors Number of chains contributing to a receptor/barcode. <code>\"proportion\"</code> <code>imd_proportion</code> annotations Proportions derived from counts. <code>\"n_receptors\"</code> <code>n_receptors</code> repertoires Total receptors in a repertoire. <code>\"n_barcodes\"</code> <code>n_barcodes</code> repertoires Total barcodes in a repertoire. <code>\"n_cells\"</code> <code>n_cells</code> repertoires Alias for barcodes when they represent cells. <code>\"n_repertoires\"</code> <code>n_repertoires</code> repertoires Count of repertoires (e.g., cohort level). <code>\"locus\"</code> <code>locus</code> annotations Chain locus (e.g., TRA, TRB, IGH, IGL). <code>\"metadata_filename\"</code> <code>imd_filename</code> annotations Source filename used during ingest. <code>\"filename\"</code> <code>filename</code> annotations User-facing filename column (if present). <p>Similarity flags (prefixes): columns created by similarity/matching utilities may use the following prefixes; the suffix is method-specific (e.g., the field compared). <code>imd_sim_exact_</code>, <code>imd_sim_regex_</code>, <code>imd_sim_hamm_</code>, <code>imd_sim_lev_</code>. </p>"},{"location":"guides/data_schema/#feature-columns-used-to-define-receptors","title":"Feature columns used to define receptors","text":"<p>Your receptor schema declares which features identify a receptor (e.g., CDR3 AA, V gene, optionally J gene), and which chains to pair (e.g., \u03b1+\u03b2). <code>Receptors</code> are computed on the fly from <code>annotations</code> using that schema. </p> <ul> <li>Typical gene/sequence fields align to AIRR-C conventions and are normalised on ingest. E.g., 10x Genomics columns are renamed: <code>v_gene \u2192 v_call</code>, <code>j_gene \u2192 j_call</code></li> <li>Common feature columns then are: <code>v_call</code>, <code>j_call</code>, and a CDR3 field (often <code>junction_aa</code>/<code>cdr3</code>/<code>cdr3_aa</code>, depending on your source). Choose the exact set when you build the receptor schema. </li> </ul>"},{"location":"guides/data_schema/#accessing-names-programmatically","title":"Accessing names programmatically","text":""},{"location":"guides/data_schema/#direct-scripts","title":"Direct (scripts)","text":"R <pre><code>library(immunarch)\n\nidata |&gt; \n    filter(imd_count &gt;= 5)\n</code></pre>"},{"location":"guides/data_schema/#schema-resolved-packages","title":"Schema-resolved (packages)","text":"R <pre><code>library(immunarch)\n\ncnt &lt;- immundata::imd_schema(\"count\")\nidata |&gt; \n    filter(!!rlang::sym(cnt) &gt;= 5)\n\n# imd_schema_sym(\"&lt;key&gt;\") == rlang::sym(imd_schema(\"&lt;key&gt;\"))\ncnt_sym &lt;- immundata::imd_schema_sym(\"count\")\nidata |&gt; \n    filter(!!cnt_sym &gt;= 5)\n\nimd_schema(\"barcode\")     # \"imd_barcode\"\nimd_schema(\"receptor\")    # \"imd_receptor_id\"\nimd_schema(\"repertoire\")  # \"imd_repertoire_id\"\n</code></pre> <p>These helpers are used internally across immunarch methods for safe joins and checks. </p>"},{"location":"guides/data_schema/#common-pitfalls-when-loading-data-and-why","title":"Common pitfalls when loading data (and why)","text":"<ul> <li>No repertoires defined: many analyses expect <code>imd_repertoire_id</code>. Create it with <code>agg_repertoires()</code> (e.g., group by <code>sample_id</code>, <code>donor</code>, <code>timepoint</code>). </li> <li>Ambiguous receptor schemas: for multi-chain receptors (\u03b1\u03b2, heavy+light), specify pairing rules (which loci to pair, tie-breakers for multiple chains per barcode). </li> </ul>"},{"location":"guides/faq/","title":"F.A.Q.","text":""},{"location":"guides/faq/#performance-speed-memory","title":"Performance \u2013 speed, memory","text":"<ol> <li> <p>Q: My workflows are slow! But you promised the new <code>immunarch</code> and <code>immundata</code> would be faster!</p> <p>A: There are a few cases where <code>immunarch 1.0</code> (powered by <code>immundata</code>) may be slower than <code>immunarch 0.9</code> or other tools.</p> <ul> <li> <p>If your dataset is small, the overhead of managing DuckDB can be larger than the computation itself.</p> </li> <li> <p>Remember immutability? If you don't create snapshots to cache results, the entire pipeline (including file reads) will run again. That may be why it feels slower. Create snapshots with <code>immundata::write_immundata()</code> after heavy steps. For example, when you're done annotating with scRNA-seq clusters or other metadata, save the updated <code>ImmunData</code> to disk so those steps don't rerun.</p> </li> </ul> <p>You can run <code>duckplyr::explain(idata$annotations)</code> to see the query plan. If it's long and hard to scroll, that's a good sign you should snapshot.</p> <p>It can feel inconvenient at first, but it gets easier. If anything is unclear, open an issue, and I'll add tutorials and best-practice guides. The benefits of this <code>dplyr</code>-like, immutable workflow are worth it.</p> </li> </ol>"},{"location":"guides/faq/#data-reading-writing-formats-engineering","title":"Data \u2013 reading, writing, formats, engineering","text":"<ol> <li> <p>Q: Why do we need <code>ImmunData</code> when there are <code>AnnData</code> and <code>MuData</code>?</p> <p>A: <code>ImmunData</code> doesn\u2019t try to replace AnnData or MuData. It solves a different problem. AnnData/MuData are great for cell \u00d7 gene data. <code>ImmunData</code> is built for AIRR data-things like receptors, clonotypes, chains, and repertoires.</p> <ul> <li> <p>Receptor-first and AIRR-aligned. <code>ImmunData</code> follows the AIRR Community schema (with a small superset). Field names are stable and clear, so you can share data and methods across tools without guessing what a column means.</p> </li> <li> <p>Aggregation is a core feature. You can define a repertoire on the fly (by sample, tissue, timepoint, therapy, etc.) and re-aggregate quickly. Counts and proportions then become well defined per repertoire, which is essential for clonality, diversity, and publicity.</p> </li> <li> <p>Works for bulk and single-cell. It handles bulk repertoires and scAIRR, supports multiple chains per barcode, pairing rules, and explicit clonotype definitions. When you need to show results in Seurat or AnnData, you simply join by <code>barcode</code> and, for example, colour a UMAP with receptor labels.</p> </li> <li> <p>Modern data engineering by default. Data live in Parquet/Arrow, queries run through DuckDB, and we use lazy evaluation. This means the pipeline scales beyond RAM and only materialises when needed. With snapshots (immutability) you can freeze expensive steps for speed and reproducibility.</p> </li> <li> <p>Ready for ML/DL. It\u2019s straightforward to build feature tables (V/J usage, k-mers, CDR3 embeddings, etc.) and export them as Parquet for training in Python, Julia, or R\u2014no messy conversions.</p> </li> <li> <p>Interoperable, not overlapping. Keep gene-expression matrices in Seurat/AnnData. Keep AIRR receptors in <code>ImmunData</code>. Join by barcode when you want the two worlds together. Each tool does what it\u2019s best at.</p> </li> <li> <p>Focused scope. Heavy or niche analyses can live in small extension packages. The core stays lean, stable, and easier to install.</p> </li> </ul> <p>When not to use it: For very small datasets (where Arrow/DuckDB overhead may dominate) or for workflows that never touch AIRR concepts (pure transcriptomics).</p> <p>In short: AnnData/MuData manage cells and genes. <code>ImmunData</code> manages receptors and repertoires. They work best together.</p> </li> <li> <p>Q: How does <code>immundata</code> works under the hood, in simpler terms?</p> <p>A: Picture a three-layer sandwich:</p> <ul> <li> <p><code>Parquet</code> files in <code>Arrow</code> column-compressed format hold the raw tables on the disk.</p> </li> <li> <p><code>DuckDB</code> is an in-process SQL engine that can query those files without loading them fully into RAM.</p> </li> <li> <p><code>duckplyr</code> glues <code>dplyr</code> verbs (filter, mutate, summarise, \u2026) to DuckDB SQL, so your R code looks exactly like a tidyverse pipeline while the heavy lifting happens in C++.</p> </li> </ul> <p>When you call <code>read_repertoires()</code>, <code>immundata</code> reads <code>Parquet</code> files, registers them with <code>DuckDB</code>, and returns a <code>duckplyr</code> table \u2013 a data frame-like structure that is in reality a lightweight database connection to <code>DuckdDB</code>. Every later operation is lazily translated into SQL - a special language for quering databases. Nothing is materialised (i.e., computed and output) until a workflow step truly needs physical data (e.g. a plot or an algorithm that exists only in R).</p> <p>References:</p> <ol> <li> <p>Arrow for R \u2013 columnar file format</p> </li> <li> <p>DuckDB \u2013 embedded analytical database</p> </li> <li> <p>duckplyr \u2013 API/implementation details</p> </li> </ol> </li> <li> <p>Q: Why do you need to create Parquet files with receptors and annotations?</p> <p>A: Those are intermediate files, optimized for future data operations, and working with them significantly accelerates <code>immundata</code>.</p> </li> <li> <p>Q: Why does <code>immundata</code> support only the AIRR-C file format?!</p> <p>A: The short answer is because a single, stable schema beats a zoo of drifting ones.</p> <p>The practical answer is that <code>immundata</code> allows some optionality \u2013 you can provide column names for barcodes, etc.</p> <p>The long answer is that the amount of investments required not only for the development, but also for the continued support of parsers for different formats, is astonishing. I developed parsers for 10+ formats for <code>tcR</code> / <code>immunarch</code> packages. I would much prefer for upstream tool developers not to change their format each minor version, breaking pretty much all downstream pipelines and causing all sorts of pain to end users and tools developers \u2013 mind you, without bearing a responsibility to at least notify, but ideally fix the broken formats they introduced. The time of the Wild West is over. The AIRR community did an outstanding job creating its standard. Please urge the creators of your favourite tools or fellow developers to use this format or a superset, like <code>immundata</code> does.</p> <p><code>immundata</code> does not and will not explicitly support other formats. This is both a practical stance and communication of crucial values, put into <code>immundata</code> as part of a broader ecosystem of AIRR tools. The domain is already too complex, and we need to work together to make this complexity manageable. A healthy ecosystem is not the same as a complex ecosystem.</p> </li> <li> <p>Q: What do I do then? I really need the output from package <code>X</code> in <code>immunarch</code>...</p> <p>A: In the previous question, I outlined the motivation behind focusing on AIRR-C format only.</p> <p>There are four practical steps that you can do:</p> <ul> <li> <p>(recommended) Ask the maintainer of the package <code>X</code> to support the AIRR-C file format. It is not that hard to implement.</p> </li> <li> <p>Use <code>read_repertoires</code> from <code>immundata</code> and create your own reader. Helpful links: <code>read_repertoires</code> reference and the full documentation website.</p> </li> <li> <p>Use the community-driven package <code>work-in-progress</code> to read files as it provides more parsers. Link: TBD</p> </li> <li> <p>If <code>work-in-progress</code> doesn't support the desired file format, you can create your own parser using <code>read_repertoires</code> and contribute it to <code>work-in-progress</code>. I personally would greatly appreciate it.</p> </li> </ul> </li> <li> <p>Q: Why are the counts for receptors available only after all the aggregation?</p> <p>A: Counts and proportions are properties of a receptor inside a specific repertoire. A receptor seen in two samples will be counted twice \u2013 once per repertoire. Until receptors and repertoires are defined, any \"count\" would be ambiguous. That's why the numbers appear only after <code>agg_receptors()</code> and <code>agg_repertoires()</code> have locked those definitions in.</p> </li> <li> <p>Q: You filter out non-productive receptors. How do I explore them?</p> <p>A: Disable filtering of non-productive receptors in the <code>preprocess</code> step of <code>read_repertoires()</code>.</p> </li> <li> <p>Q: Why does <code>immundata</code> have its own column names for receptors and repertoires? Could you just use the AIRR format - repertoire_id etc.?</p> <p>A: The power of <code>immundata</code> is fast re-aggregation, which lets you define what repertoire means on the fly via <code>agg_repertoires()</code>. That's why we use a superset of AIRR field names, which is totally acceptable as per their documentation.</p> </li> <li> <p>Q: What do I do with following error: \"Error in <code>compute_parquet()</code> at [...]: ! ?*</p> <p>A: It means that your repertoire files have different schemas, i.e., different column names. You have two options.</p> <p>Option 1: Check the data and fix the schema. Explore the reason why the data have different schemas. Remove wrong files. Change column names. And try again.</p> <p>Option 2: If you know what you are doing, pass argument <code>enforce_schema = FALSE</code> to <code>read_repertoires</code>. The resultant table will have NAs in the place of missing values. But don't use it without considering the first option. Broken schema usually means that there are some issues in how the data were processed upstream.</p> </li> </ol>"},{"location":"guides/faq/#interface-functions-methods-naming","title":"Interface \u2013 functions, methods, naming","text":"<ol> <li> <p>Q: Why all the function names or ImmunData fields are so long? I want to write <code>idata$rec</code> instead of <code>idata$receptors</code>.</p> <p>A: Two main reasons: readability and encouraging autocomplete. Use your IDE's Tab to trigger autocomplete; it can speed you up 10\u201320\u00d7.</p> </li> <li> <p>Q: Why is it so complex? Why do we need to use <code>dplyr</code> instead of plain R?</p> </li> </ol> <p>A: The short answer is:    - faster computations;    - code that is easy to maintain and support by other humans;    - better data skills by thinking in immutable transformations;    - in most cases you don't need complex transformations, so we can optimise ~95% of AIRR operations behind the scenes.</p> <ol> <li> <p>Q: How do I use <code>dplyr</code> operations that <code>duckplyr</code> doesn't support yet?</p> <p>A: Let's consider several use cases.</p> <p>Case 0. You are missing <code>group_by</code> from <code>dplyr</code>. Use <code>summarise(.by = ???, ...)</code>.</p> <p>Case 1. Your data can fit into RAM. Call <code>collect</code> and use <code>dplyr</code>.</p> <p>Case 2. Your data won't fit into RAM but you must run a heavy operation on all rows. You can rewrite functions in SQL. You can break it into supported pieces (e.g. pre-filter, pre-aggregate) that DuckDB can stream, write an intermediate Parquet with <code>compute_parquet()</code>, then loop over chunks, collect them, and run the analysis.</p> <p>Case 3. Your data won't fit into RAM, but before running intensive computations, you are open to working with smaller dataset first. Filter down via <code>slice_head(n=...)</code>, iterate until the code works, then run the same pipeline on the full dataset.</p> </li> </ol>"},{"location":"guides/faq/#miscellaneous","title":"Miscellaneous","text":"<ol> <li> <p>Q: <code>immundata</code> is too verbose, I'm tired of all the messages. How to turn them off?</p> <p>A: Run the following code <code>options(rlib_message_verbosity = \"quiet\")</code> in the beginning of your R session to turn off messages.</p> </li> <li> <p>Q: I don't want to use <code>pak</code>, how can I use the good old <code>install.packages</code> or <code>devtools</code>?</p> <p>A: Nothing will stop you, eh? You are welcome, but I'm not responsible if something won't work due to issues with dependencies:</p> <p>```r    # CRAN release    install.packages(\"immundata\")    library(immundata)</p> </li> </ol> <p># GitHub release    install.packages(\"devtools\")    devtools::install_github(\"immunomind/immundata\")    library(immundata)</p> <p># Development version (dev branch)    devtools::install_github(\"immunomind/immundata\", ref = \"dev\")    library(immundata)    ```</p>"},{"location":"howto/immunarch_import/","title":"Convert <code>immunarch::repLoad()</code> output to <code>ImmunData</code> in R","text":"<p>Use this to migrate your immunarch v0.9 repertoires into an ImmunData dataset from <code>immunarch 0.10/1.0</code>.</p> <p>How it works:</p> <ul> <li>Takes an <code>immunarch::repLoad()</code> object (<code>imm</code>).</li> <li>Writes one TSV per repertoire (adds a filename column) to <code>temp_folder</code>.</li> <li>Imports those TSVs with <code>read_repertoires()</code> into ImmunData.</li> <li>Saves Parquet files under <code>output_folder</code>; returns an ImmunData object.</li> </ul> <p>Key arguments:</p> <ul> <li><code>imm</code>: output of <code>immunarch::repLoad()</code>.</li> <li><code>output_folder</code>: where Parquet data will be stored (auto-created).</li> <li><code>schema</code>: character vector defining unique receptor keys   (default <code>c(\"CDR3.aa\", \"V.name\")</code>; you can add <code>\"J.name\"</code>).</li> <li><code>temp_folder</code>: where intermediate TSVs are written (defaults to a temp dir).</li> </ul> R <pre><code>library(immunarch)\n\n# 1) Load your immunarch object (reads all repertoires + optional metadata)\nimmdata &lt;- immunarch::repLoad(\"/path/to/your/files\")\n\n# 2) Convert to ImmunData (Parquet-backed), customizing receptor key if needed\nidata &lt;- from_immunarch(\n  imm           = immdata,\n  schema        = c(\"CDR3.aa\", \"V.name\"),    \n  output_folder = \"/path/to/immundata_out\"\n)\n\nidata\n</code></pre> <p>Optionally, you can rename the columns in your <code>immdata</code> object before passing to <code>from_immunarch</code> to align it with AIRR-C format:</p> R <pre><code>rename_to_airr &lt;- function(df) {\n  map &lt;- c(\n    \"CDR3.aa\"   = \"cdr3_aa\",\n    \"CDR3.nt\"   = \"cdr3_nt\",\n    \"V.name\"    = \"v_call\",\n    \"D.name\"    = \"d_call\",\n    \"J.name\"    = \"j_call\",\n    \"Clones\"    = \"umi_count\",\n    \"Read.count\"= \"duplicate_count\",\n    \"Barcode\"   = \"cell_id\",\n    \"barcode\"   = \"cell_id\",\n    \"Chain\"     = \"locus\",\n    \"Gene\"      = \"locus\",\n    \"Productive\"= \"productive\"\n  )\n\n  present_old &lt;- intersect(names(df), names(map))\n  if (!length(present_old)) return(df)\n\n  new_names &lt;- unname(map[present_old])\n  keep &lt;- !duplicated(new_names)\n  present_old &lt;- present_old[keep]\n  new_names    &lt;- new_names[keep]\n\n  spec &lt;- stats::setNames(rlang::syms(present_old), new_names)\n  dplyr::rename(df, !!!spec)\n}\n\nimmdata$data &lt;- lapply(immdata$data, rename_to_airr)\n</code></pre>"},{"location":"howto/no_threads/","title":"Limit the number of threads used by <code>immunarch</code> (DuckDB)","text":""},{"location":"howto/no_threads/#what-is-happening-under-the-hood","title":"What is happening under the hood?","text":"<p><code>immunarch</code> uses <code>immundata</code>, which uses <code>duckplyr</code>, which runs queries in DuckDB. It is quite a journey from the data to your plots. </p> <p>DuckDB can use many CPU cores by default to run faster, but sometimes you want to limit this.</p>"},{"location":"howto/no_threads/#why-limit-threads","title":"Why limit threads?","text":"<ul> <li>On shared machines (servers, CI), many threads can slow down other users.</li> <li>In tutorials, fewer threads make examples more predictable and easier to reproduce.</li> <li>Lower threads = lower CPU load (but slower queries).</li> </ul>"},{"location":"howto/no_threads/#how-to-limit-the-number-of-threads","title":"How to limit the number of threads","text":"<p>Put this near the start of your tutorial/script:</p> R <pre><code># Limit the number of CPU threads used by DuckDB in this R session\nduckplyr::db_exec(\"SET threads TO 1\")\n</code></pre> <p>Change later (example: use 4 threads) or reset to default:</p> R <pre><code>duckplyr::db_exec(\"SET threads TO 4\")   # use 4 threads\n# or, if supported in your environment:\nduckplyr::db_exec(\"RESET threads\")      # back to DuckDB default\n</code></pre>"},{"location":"howto/no_threads/#references","title":"References","text":"<ul> <li> <p><code>duckplyr</code> - <code>dplyr</code> powered by DuckDB: https://duckplyr.tidyverse.org (CRAN: duckplyr).</p> </li> <li> <p><code>db_exec</code> - https://duckplyr.tidyverse.org/reference/db_exec.html</p> </li> <li> <p>DuckDB configuration docs - thread/memory settings and more: https://duckdb.org/docs/stable/configuration/overview.html</p> </li> </ul>"},{"location":"howto/read_10_single/","title":"Read 10 single","text":"<pre><code>    #| label: load-dataset-types-10x\n    #| eval: false\n\n    #\n    # AIRR-C\n    #\n    schema &lt;- make_receptor_schema(features = c(\"junction_aa\", \"v_call\"), chains = \"TCRB\")\n    # or\n    schema &lt;- make_receptor_schema(features = c(\"cdr3_aa\", \"v_call\"), chains = \"TCRB\")\n    # reminder how to read paired-chain data if needed:\n    schema &lt;- make_receptor_schema(features = c(\"cdr3_aa\", \"v_call\"), chains = c(\"TCRA\", \"TCRB\"))\n\n    idata &lt;- read_repertoires(path = inp_files, \n                              schema = schema, \n                              metadata = md_table,\n                              barcode_col = \"cell_id\",\n                              locus_col = \"locus\",\n                              umi_col = \"umi_count\", \n                              preprocess = make_default_preprocessing(\"airr\"), \n                              repertoire_schema = \"Tissue\")\n\n    #\n    # 10XGenomics\n    #\n\n    # This is how the original schema would look like\n    schema &lt;- make_receptor_schema(features = c(\"cdr3_aa\", \"v_gene\"), chains = \"TRB\")\n\n    idata &lt;- read_repertoires(path = inp_files, \n                              schema = schema, \n                              metadata = md_table, \n                              barcode_col = \"barcode\", \n                              locus_col = \"chain\", \n                              umi_col = \"umis\", \n                              preprocess = make_default_preprocessing(\"10x\"),\n                              rename_columns = NULL,\n                              repertoire_schema = \"Tissue\")\n\n    # Immundata renames some columns by default to match them with AIRR-C format.\n    # So we use this:\n    schema &lt;- make_receptor_schema(features = c(\"cdr3\", \"v_call\"), chains = \"TRB\")\n\n    idata &lt;- read_repertoires(path = inp_files, \n                              schema = schema, \n                              metadata = md_table, \n                              barcode_col = \"barcode\", \n                              locus_col = \"locus\", \n                              umi_col = \"umis\", \n                              preprocess = make_default_preprocessing(\"10x\"),\n                              repertoire_schema = \"Tissue\")\n    ```\n\n\n\n---\n\n# Load 10x Genomics V(D)J (single locus) to `immunarch` in R\n\n**Intro:** Use this to keep only one locus (e.g., TRB) from 10x `filtered_contig_annotations.csv`.\n\n**What happens**\n\n* Reads 10x contig annotations.\n* Selects one locus per barcode (e.g., TRB).\n* Optionally chooses the best contig by UMI/read count.\n\n**Key arguments**\n\n* `path`: `filtered_contig_annotations.csv`\n* `barcode_col`: `\"barcode\"`\n* `locus_col`: `\"chain\"`\n* `umi_col` (optional): e.g., `umis` or `reads`\n* `schema`: restrict to the locus you want (e.g., `\"TRB\"`)\n\n```r\nlibrary(immunarch)\n\nschema &lt;- make_receptor_schema(features = c(\"v_call\", \"j_call\", \"cdr3\"), chains = \"TRB\")\nidata &lt;- read_repertoires(\n  path        = \"/path/to/filtered_contig_annotations.csv\",\n  schema      = schema,\n  barcode_col = \"barcode\",\n  locus_col   = \"chain\",\n  umi_col     = \"umis\"              # or \"reads\", if present\n)\n</code></pre>"},{"location":"howto/read_10_single/#load-10x-genomics-vdj-paired-tratrb-to-immunarch-in-r","title":"Load 10x Genomics V(D)J (paired TRA+TRB) to <code>immunarch</code> in R","text":"<p>Intro: Use this to build paired \u03b1/\u03b2 repertoires from 10x contig annotations.</p> <p>What happens</p> <ul> <li>Reads 10x contigs per barcode.</li> <li>Selects the top TRA and the top TRB per barcode (by UMI/reads if provided).</li> <li>Produces paired receptors per cell.</li> </ul> <p>Key arguments</p> <ul> <li><code>path</code>: <code>filtered_contig_annotations.csv</code> (or <code>all_contig_annotations.csv</code>)</li> <li><code>barcode_col</code>: <code>\"barcode\"</code></li> <li><code>locus_col</code>: <code>\"chain\"</code></li> <li><code>umi_col</code> (recommended): e.g., <code>umis</code> or <code>reads</code></li> <li><code>schema</code>: expect both loci (<code>TRA</code>, <code>TRB</code>)</li> </ul> <pre><code>library(immunarch)\n\nschema &lt;- make_receptor_schema(features = c(\"cdr3\"), chains = c(\"TRA\", \"TRB\"))\nidata &lt;- read_repertoires(\n  path        = \"/path/to/filtered_contig_annotations.csv\",\n  schema      = schema,\n  barcode_col = \"barcode\",\n  locus_col   = \"chain\",\n  umi_col     = \"umis\"              # recommended for best-contig selection\n)\n</code></pre> <p>If you want, I can add tiny \u201cverify\u201d snippets (e.g., check locus distribution, pairing rate) right under each recipe.</p>"},{"location":"howto/read_airr_bulk/","title":"Load bulk sequencing immune repertoire data in AIRR-C format to <code>immunarch</code> in R","text":"<p>Use this for bulk AIRR Rearrangement TSVs (one row per rearrangement/receptor). Requirements: installed <code>immunarch</code>.</p> <p>How it works:</p> <ul> <li>Reads all AIRR-C TSVs from a folder (bulk mode).</li> <li>Maps AIRR fields (e.g., <code>v_call</code>, <code>j_call</code>, <code>junction_aa</code>) to a receptor schema.</li> <li>Uses the provided count column to set receptor abundance.</li> </ul> <p>Key arguments:</p> <ul> <li><code>schema</code>: features you need (e.g., <code>junction_aa</code>, <code>v_call</code>, <code>j_call</code>)</li> <li><code>path</code>: file, glob, or folder with your files</li> <li><code>count_col</code>: usually <code>umi_count</code> or <code>duplicate_count</code> (adjust if your column name differs)</li> </ul> R <pre><code>library(immunarch)\n\nschema &lt;- make_receptor_schema(features = c(\"junction_aa\", \"v_call\"))\n# Alternative:\nschema &lt;- make_receptor_schema(features = c(\"cdr3_aa\", \"v_call\"))\n\nidata &lt;- read_repertoires(\n  path       = \"/path/to/bulk_airr/*.tsv\",\n  schema     = schema,\n  count_col  = \"umi_count\",\n  preprocess = make_default_preprocessing(\"airr\")\n)\n\n# If you have metadata, you can use it:\nidata &lt;- read_repertoires(\n  path       = \"/path/to/bulk_airr/*.tsv\",\n  metadata   = your_metadata_table,\n  schema     = schema,\n  count_col  = \"umi_count\",\n  preprocess = make_default_preprocessing(\"airr\")\n)\n\n# If you already know the repertoire schema:\nidata &lt;- read_repertoires(\n  path              = \"/path/to/bulk_airr/*.tsv\",\n  metadata          = your_metadata_table,\n  schema            = schema,\n  count_col         = \"umi_count\",\n  preprocess        = make_default_preprocessing(\"airr\"),\n  repertoire_schema = c(\"Patient\", \"Cluster\", \"Response\")\n)\n</code></pre>"},{"location":"howto/read_airr_sc/","title":"Load single-cell sequencing immune repertoire data in AIRR-C format to <code>immunarch</code> in R","text":"<p>Use this when your single-cell data export is AIRR-C and includes cell barcodes and a <code>locus</code> column.</p> <p>How it works:</p> <ul> <li>Reads AIRR-C TSV with one row per contig.</li> <li>Groups by barcode, pairs by <code>locus</code> (e.g., <code>TRA</code> + <code>TRB</code>). Alternatively, selects the specified locus only.</li> <li>Picks the top contig per locus using a UMI/read column.</li> </ul> <p>Key arguments:</p> <ul> <li><code>schema</code>: features you need (e.g., <code>junction_aa</code>, <code>v_call</code>, <code>j_call</code>)</li> <li><code>path</code>: file, glob, or folder with your files</li> <li><code>barcode_col</code>: column with barcodes - <code>cell_id</code></li> <li><code>locus_col</code>: column iwht loci information - <code>\"locus\"</code></li> <li><code>umi_col</code>: column with UMI information, usually it is either <code>umi_count</code> or <code>duplicate_count</code></li> </ul> R <pre><code>library(immunarch)\n\n# If you have two chains, you can select one and filter out others:\nschema &lt;- make_receptor_schema(features = c(\"junction_aa\", \"v_call\"), chains = c(\"TCRA\"))\n# Or you can create paired-chain receptors:\nschema &lt;- make_receptor_schema(features = c(\"junction_aa\", \"v_call\"), chains = c(\"TCRA\", \"TCRB\"))\n\nidata &lt;- read_repertoires(\n  path        = \"/path/to/sc_airr/*.tsv\",\n  schema      = schema,\n  barcode_col = \"cell_id\",\n  locus_col   = \"locus\",\n  umi_col     = \"umi_count\",\n  preprocess  = make_default_preprocessing(\"airr\")\n)\n\n# If you have metadata, you can use it:\nidata &lt;- read_repertoires(\n  path        = \"/path/to/sc_airr/*.tsv\",\n  schema      = schema,\n  metadata    = your_metadata_table,\n  barcode_col = \"cell_id\",\n  locus_col   = \"locus\",\n  umi_col     = \"umi_count\",\n  preprocess  = make_default_preprocessing(\"airr\")\n)\n\n# If you already know the repertoire schema:\nidata &lt;- read_repertoires(\n  path              = \"/path/to/sc_airr/*.tsv\",\n  schema            = schema,\n  metadata          = your_metadata_table,\n  barcode_col       = \"cell_id\",\n  locus_col         = \"locus\",\n  umi_col           = \"umi_count\",\n  preprocess        = make_default_preprocessing(\"airr\"),\n  repertoire_schema = c(\"Patient\", \"Cluster\", \"Response\")\n)\n</code></pre>"},{"location":"intro/installation/","title":"Installation","text":"<p>This guide installs the analysis toolkit <code>immunarch</code> for repertoire analysis. The data layer <code>immundata</code> ships with <code>immunarch</code> and loads automatically, so you do not need to install it separately for typical workflows. Advanced users will find optional <code>immundata</code> install steps at the end.</p>"},{"location":"intro/installation/#requirements","title":"Requirements","text":"<ul> <li>R \u2265 4.2 recommended</li> <li>Internet access to install packages</li> </ul>"},{"location":"intro/installation/#1-install-pak-recommended-installer","title":"1) Install <code>pak</code> (recommended installer)","text":"R <pre><code>install.packages(\"pak\", repos = sprintf(\"https://r-lib.github.io/p/pak/stable/%s/%s/%s\", .Platform$pkgType, R.Version()$os, R.Version()$arch))\n</code></pre>"},{"location":"intro/installation/#2-install-immunarch-includes-immundata","title":"2) Install <code>immunarch</code> (includes <code>immundata</code>)","text":"<p>Use the GitHub build if you want the newest features.</p> R <pre><code># Latest GitHub build\npak::pkg_install(\"immunomind/immunarch\")\n\n# Or install from CRAN when available\npak::pkg_install(\"immunarch\")\n</code></pre>"},{"location":"intro/installation/#verify-the-installation","title":"Verify the installation","text":"R <pre><code>library(immunarch)\npackageVersion(\"immunarch\")\n# immundata is bundled; it will be available when you load immunarch\n</code></pre>"},{"location":"intro/installation/#reproducible-environments","title":"Reproducible environments","text":"<p>Pin an exact version (tag or SHA) for papers and CI:</p> R <pre><code>pak::pkg_install(\"immunomind/immunarch@v0.9.1\")\n</code></pre>"},{"location":"intro/installation/#optional-install-immundata-alone","title":"Optional: install <code>immundata</code> alone","text":"<p>Only needed if you want to work directly with the data layer API, build ingestion pipelines, or contribute.</p> R <pre><code># Latest GitHub build\npak::pkg_install(\"immunomind/immundata\")\n\n# Or CRAN when available\npak::pkg_install(\"immundata\")\n\n# Pin a specific version\npak::pkg_install(\"immunomind/immundata@0.2.1\")\n</code></pre>"},{"location":"intro/quick_start/","title":"Quick Start","text":"<p>A five\u2011minute tour: load <code>immunarch</code>, get example data, run core analyses, and ingest AIRR data with the bundled <code>immundata</code> tools.</p>"},{"location":"intro/quick_start/#1-load-the-toolkit","title":"1) Load the toolkit","text":"R <pre><code>library(immunarch)\n</code></pre>"},{"location":"intro/quick_start/#2-get-example-data-and-set-a-grouping","title":"2) Get example data and set a grouping","text":"R <pre><code># Small demo dataset\nidata &lt;- get_test_idata() |&gt; agg_repertoires(\"Therapy\")\n\n# Print a compact summary\nidata\n</code></pre>"},{"location":"intro/quick_start/#3-firstlook-analyses","title":"3) First\u2011look analyses","text":"R <pre><code># Gene usage (e.g., V gene)\nairr_stats_genes(idata, gene_col = \"v_call\") |&gt; vis()\n\n# Publicity / overlap\nairr_public_jaccard(idata) |&gt; vis()\n\n# Clonality (proportion bins)\nairr_clonality_prop(idata)\n\n# Diversity (evenness)\nairr_diversity_pielou(idata) |&gt; vis()\n</code></pre>"},{"location":"intro/quick_start/#4-optional-annotate-clonality-per-receptor-and-plot-in-seurat","title":"4) (Optional) Annotate clonality per receptor and plot in Seurat","text":"R <pre><code># Add per\u2011receptor clonality labels\nidata &lt;- annotate_clonality_prop(idata)\n\n# Copy labels to a Seurat object by barcode and color UMAP\n# (Assumes you created `sdata` earlier in your workflow)\nsdata &lt;- annotate_seurat(idata, sdata, cols = \"clonal_prop_bin\")\nSeurat::DimPlot(sdata, reduction = \"umap\", group.by = \"clonal_prop_bin\", shuffle = TRUE)\n</code></pre>"},{"location":"intro/quick_start/#5-optional-ingest-airr-data-with-the-bundled-data-layer","title":"5) (Optional) Ingest AIRR data with the bundled data layer","text":"<p><code>immundata</code> ships with <code>immunarch</code>. You can call its readers directly for flexible ingestion.</p> R <pre><code># Read AIRR TSVs (toy example)\nmd_path &lt;- system.file(\"extdata/tsv\", \"metadata.tsv\", package = \"immundata\")\nfiles &lt;- c(\n    system.file(\"extdata/tsv\", \"sample_0_1k.tsv\", package = \"immundata\"),\n    system.file(\"extdata/tsv\", \"sample_1k_2k.tsv\", package = \"immundata\")\n)\n\nmd &lt;- read_metadata(md_path)\nidata &lt;- read_repertoires(\npath     = files,\nschema   = c(\"cdr3_aa\", \"v_call\"),\nmetadata = md\n)\n\n# Continue with immunarch analyses\nidata |&gt; agg_repertoires(\"Therapy\") |&gt; airr_clonality_prop()\n</code></pre>"},{"location":"intro/quick_start/#next-steps","title":"Next steps","text":"<ul> <li>Explore our detailed Tutorials.</li> </ul>"},{"location":"tutorials/migration/","title":"Migration from immunarch v0.9 to v1.0","text":"<p>This guide is for existing <code>immunarch</code> users. If you're new to <code>immunarch</code>, you can safely skip this tutorial.</p> <p>Note: The 0.9.y versions of <code>immunarch</code> (e.g., 0.9.1) are no longer supported. If something breaks (e.g., due to a dependency update), it will not be fixed. I highly recommend upgrading to version 0.10 as soon as possible. Version 0.10 serves as a pre-release version for 1.0, and feature parity between 0.9 and 1.0 will be achieved within a few months. Once it is done, the version 0.10.x will be switched to 1.0.</p> <p>I'm prioritizing feature parity, stability, and enhancements for the most common workflows as well as advanced use cases relevant to immunotherapy development. If you need help with migration or run into issues, please open an issue on GitHub - I'm happy to help.</p>"},{"location":"tutorials/migration/#high-level-overview-of-v10-changes","title":"High-level overview of v1.0 changes","text":"<p>Version 1.0 introduces several important changes compared to the 0.9.x series.</p>"},{"location":"tutorials/migration/#1-working-with-data","title":"1) Working with data","text":"<p>Version 1.0 embraces a much clearer data layer centered on ImmunData from <code>immundata</code> R package. ImmunData is a lightweight, consistent data structure for working with chains, receptors, and repertoires. It promotes immutability, i.e., functions no longer mutate your data in place, but instead return new objects. This makes pipelines easier to reason about and eliminates hidden side effects, but requires changes in how you think about the data analysis. Read more in the Concepts section.</p> <p>ImmunData is designed to be scale-agnostic. Today, you can use small immune repertoire samples; tomorrow, you can plug in larger-than-memory datasets with zero changes to your code. The API remains stable and your analysis code stays simple.</p>"},{"location":"tutorials/migration/#2-api-changes","title":"2) API changes","text":"<p>Some function signatures have changed. Large, multi-tool functions are now split into smaller, focused ones.</p> <p>Example: The old <code>repDiversity()</code> meta-function is now a family of functions, each with a clear, shared prefix. For instance, you now call <code>airr_diversity_shannon()</code> or <code>airr_diversity_pielou()</code>. These functions are still grouped under one help page so you can compare them and discover new metrics easily. Simply run <code>?airr_diversity</code> to get a list of all functions in the family. This holds for virtually all other function families - <code>?airr_stats</code>, <code>?airr_clonality</code>, <code>?annotate_clonality</code>, etc.</p> <p>You'll find smaller, clearer tools with consistent naming and arguments throughout. The reason is that with huge multi-tool functions such as <code>repOverlap</code> it requires a lot of cognitive investment to remember specific method arguments. With smaller function you can effortlessly invoke a help from IDE itself via autocomplete by pressing \"tab\" while typing the function name.</p> <ul> <li>Watch for deprecations. If the console says \"deprecated\" or \"will be removed in v1.1.0\", please update your code soon. Compatibility shims are temporary and will eventually be removed.</li> </ul>"},{"location":"tutorials/migration/#3-fewer-heavy-dependencies","title":"3) Fewer heavy dependencies","text":"<p>Many packages were moved from <code>Depends</code> to <code>Suggests</code>. As a result, <code>immunarch</code> now installs much faster and brings in far fewer dependencies. The 0.9 version would pull in around 140 packages on a clean machine, while 0.10 is closer to 80. If you use a feature that requires an optional package, you'll see a clear prompt telling you what to install.</p>"},{"location":"tutorials/migration/#4-working-with-visualizations","title":"4) Working with visualizations","text":"<p>The <code>vis()</code> function family has not been implemented for the new analysis functions \u2013 yet. This was a deliberate choice. The major downside of <code>vis()</code> lies in its general nature: sadly, one-size-fits-all didn't work as expected. Programmatically producing publication-ready plots is extremely challenging, and most users end up editing the generated plots to fit journal requirements anyway. For examples of what's involved in preparing plots to publication, see this guide to publication-ready ggplot2.</p> <p>Currently, I provide ggplot2 code templates for common publication figures in the tutorials and guides. This approach not only helps you learn ggplot2 (the standard for scientific plotting in R), but also ensures your figures match your desired style or journal specifications right from the start.</p> <p>My plan is to update <code>vis()</code> to support 1.0 analysis methods. Run <code>?vis()</code> to check if something changed and there is no \"deprecated\" flag. However, the new implementation strategy will be completely different: opinionated and lightweight visualisations in 1.0 instead of heavy and general solutions for all possible use cases in 0.9. In other words, new <code>vis()</code> won't be able to produce all kinds of plots. The created plots will serve the major purpose of helping you quickly understand your data, rather than providing all the tweaks and gears for publication-ready plots. And if you want to change something, please use <code>ggplot2</code> and read that great guide on publication-ready plots.</p> <ul> <li>Where can I find themes and palettes? Check out ggsci and this curated palette list for easy, beautiful color options.</li> </ul> <p>To view the latest migration updates, run <code>get_immunarch_news()</code> in your R console.</p>"},{"location":"tutorials/migration/#if-you-must-stay-on-immunarch-v09","title":"If you must stay on <code>immunarch</code> v0.9","text":"<p>If you absolutely must freeze the last stable version before 1.0, use one of the following installation methods:</p> <ul> <li>pak:</li> </ul> <p><pre><code>pak::pkg_install(\"immunarch@=0.9.1\")\n</code></pre> * install.packages:</p> <p><pre><code>install.packages(\"https://cran.r-project.org/src/contrib/Archive/immunarch/immunarch_0.9.1.tar.gz\", repos = NULL, type = \"source\")\n</code></pre> * conda:</p> <pre><code>mamba install -c conda-forge r-immunarch=0.9.1\n</code></pre> <p>Reminder: 0.9.x will receive no further updates or fixes.</p>"},{"location":"tutorials/migration/#why-do-i-even-need-10","title":"Why do I even need 1.0?","text":"<ul> <li>Outdated code is hard to maintain, especially in academic environments where developer turnover is high. New <code>immunarch</code> code is much easier to support and remember what it does.</li> <li>Improved code culture: modern best practices, standard data structures, consistent naming, and more - all of this in the new ecosystem of tools, where <code>immunarch</code> is the core.</li> <li>Lazy backends for large-scale data: thanks to amazing people behind DuckDB, duckplyr, Arrow and Parquet, <code>immunarch</code> now supports out-of-memory datasets without any code changes on your side.</li> <li>Parallelization: where possible, <code>immunarch</code> steps will run in parallel out of the box, speeding up your analyses, efficiently using modern server architecture.</li> </ul> <p>Stay tuned for updates in 2025. If you have questions or migration issues, please reach out on GitHub. Thank you!</p>"},{"location":"tutorials/single_cell/","title":"Comprehensive analysis of single-cell immune repertoire data using `immunarch` and `immundata`","text":""},{"location":"tutorials/single_cell/#introduction","title":"Introduction","text":"<p>This vignette is a practical, end\u2011to\u2011end guide to analyzing single\u2011chain and paired\u2011chain Adaptive Immune Receptor Repertoire (AIRR) data derived from single\u2011cell assays (scRNA\u2011seq with VDJ; also referred to as scVDJ\u2011seq / scTCR\u2011seq / scBCR\u2011seq). It starts from the basics and builds up to more advanced analyses, so it can serve both as a first stop for newcomers and as a focused introduction for experienced readers who want to learn <code>immunarch</code> and <code>immundata</code> specifically.</p>"},{"location":"tutorials/single_cell/#what-youll-learn","title":"What you'll learn","text":"<ul> <li>Load single\u2011cell V(D)J data and metadata into     <code>immunarch</code>/<code>immundata</code>.</li> <li>Define clonotypes (AA vs NT), set chain\u2011pairing rules, and perform     essential QC.</li> <li>Explore repertoire features: expansion, gene usage, CDR3 properties,     and diversity.</li> <li>Quantify overlap/similarity between samples and conditions.</li> <li>Link clonotypes to single\u2011cell transcriptomic clusters for     downstream interpretation.</li> </ul>"},{"location":"tutorials/single_cell/#dataset-used-in-this-tutorial","title":"Dataset used in this tutorial","text":"<p>We will work with data for patient 6 from the study \"Peripheral T cell expansion predicts tumour infiltration and clinical response\" (Wu et\u00a0al.; Nature 579:274--278, 2020). The dataset includes three compartments per patient: tumour, peripheral blood, and normal adjacent tissue (NAT). We will demonstrate a typical single\u2011cell AIRR workflow across these three samples. Bulletpoint description of this great study:</p> <ul> <li>Deep single\u2011cell RNA/TCR profiling across tumour, NAT, and blood</li> <li>Clonotypic expansion of effector\u2011like T cells in and around tumours</li> <li>Ppatients with stronger peripheral expansion signatures tend to     respond better to anti\u2011PD\u2011(L)1 therapy</li> <li>Expanded intratumoural clonotypes are often detectable in blood,     enabling convenient monitoring</li> </ul> <p>References &amp; data access:</p> <ul> <li>Wu TD, Madireddi S, de Almeida PE, et\u00a0al. Nature (2020).     \"Peripheral T cell expansion predicts tumour infiltration and     clinical response.\"</li> <li>GEO series: GSE139555 (single\u2011cell RNA/TCR; pretreatment samples     from 14 patients; tumour/NAT/blood).</li> </ul>"},{"location":"tutorials/single_cell/#helpful-links","title":"Helpful links","text":"<ul> <li>Source code and issue tracker:     <code>immunarch</code> \u00b7     <code>immundata</code></li> <li>Interactive assistant: AIRR\u2011GPT --- a GPT Store model preloaded     with <code>immunarch</code> and <code>immundata</code> docs to help you as you go:     https://chatgpt.com/g/g-67fe54e302348191814e4ef2efb3bad5-airr-gpt</li> </ul>"},{"location":"tutorials/single_cell/#setup","title":"Setup","text":"R"},{"location":"tutorials/single_cell/#pre-requisites","title":"Pre-requisites","text":"<ul> <li>R \u2265 4.2 (4.3+ recommended)</li> <li>Internet access to install packages and download data from GEO</li> <li>\\~2\u20134 GB RAM free for the small demonstration subset used here</li> </ul> <p>You can install the required packages with pak (recommended for reproducibility and fast binary installs) or with base installers.</p>"},{"location":"tutorials/single_cell/#using-pak","title":"Using <code>pak</code>","text":"R <pre><code>install.packages(\"pak\", repos = sprintf(\"https://r-lib.github.io/p/pak/stable/%s/%s/%s\", .Platform$pkgType, R.Version()$os, R.Version()$arch))\n\npak::pkg_install(\"immunomind/immunarch\")\npak::pkg_install(\"Seurat\")\npak::pkg_install(\"BiocFileCache\")\npak::pkg_install(\"ggthemes\")\npak::pkg_install(\"ggsci\")\n</code></pre>"},{"location":"tutorials/single_cell/#using-cran","title":"Using CRAN","text":"R <pre><code>install.packages(c(\"immunarch\", \"Seurat\", \"BiocFileCache\", \"ggthemes\", \"ggsci\"))\n</code></pre> <p>Tip: If you prefer fully reproducible environments, consider using <code>renv::init()</code> to snapshot package versions.</p>"},{"location":"tutorials/single_cell/#load-necessary-packages-and-setup","title":"Load necessary packages and setup","text":"R <pre><code># Silence noisy startup messages while loading\nsuppressPackageStartupMessages({\n  library(immunarch)\n  library(Seurat)\n  library(BiocFileCache)\n  library(ggplot2)\n  library(ggthemes)\n  library(ggsci)\n})\n\ntheme_set(ggthemes::theme_few())\n\n# Keep a snapshot of versions for reproducibility (printed at the end as well)\npkg_versions &lt;- list(\n  immunarch = as.character(utils::packageVersion(\"immunarch\")),\n  immundata = as.character(utils::packageVersion(\"immundata\")),\n  Seurat    = as.character(utils::packageVersion(\"Seurat\"))\n)\n\npkg_versions\n</code></pre> <pre><code>$immunarch\n[1] \"0.10.3\"\n\n$immundata\n[1] \"0.0.5\"\n\n$Seurat\n[1] \"5.3.0\"\n</code></pre>"},{"location":"tutorials/single_cell/#typical-workflow-from-files-to-analysis","title":"Typical workflow: from files to analysis","text":"<p>Analyzing single-cell AIRR data with <code>immunarch 1.0</code> powered by <code>immundata</code> follows a clear, reproducible workflow that separates data ingestion from downstream transformation and annotation. This design enables you to process and reuse large datasets efficiently without manual reloading or reprocessing.</p> <p>The general workflow is:</p> <ol> <li> <p>Ingestion phase</p> <ul> <li>Read metadata (optional but recommended)</li> <li>Load AIRR-seq files and preprocess as needed</li> <li>Define receptors using a schema (single or paired chains, custom     features)</li> <li>Aggregate and persist the dataset as an immutable on-disk     <code>ImmunData</code> object</li> </ul> </li> <li> <p>Transformation phase</p> <ul> <li>Annotate <code>ImmunData</code> with external information (e.g., scRNA-seq     clusters)</li> <li>Regroup repertoires on the fly (e.g., by tissue, donor, or cell     state)</li> <li>Filter, mutate, and compute statistics without copying or     reloading data</li> <li>Visualize results, save plots, or export annotations back to     Seurat/AnnData</li> </ul> </li> </ol> <p>This separation of phases lets you:</p> <ul> <li>Ingest and persist raw AIRR-seq data once, then reload instantly for     any analysis</li> <li>Dynamically regroup receptors or repertoires, and annotate data     without touching the original files</li> <li>Build fully reproducible pipelines, as each step leaves previous     data untouched</li> </ul> <p>You can read more about the phases in Concepts.</p>"},{"location":"tutorials/single_cell/#note-on-materialization","title":"Note on materialization","text":"<p>The <code>ImmunData</code> object in <code>immundata</code> is designed to handle large, out-of-memory datasets efficiently. Instead of loading everything into RAM, it tracks computations and only runs them when the results are actually needed---such as for plotting or summarizing data. This is called lazy evaluation.</p> <p>Materialization means executing all pending computations and bringing the results into memory as a concrete table or data frame. This approach is powerful for working with large datasets, but can be unfamiliar if you're used to working entirely in-memory.</p> <p>If you see an error like:</p> <pre><code>Error: Materialization is disabled, use collect() or as_tibble() to materialize.\n</code></pre> <p>...it means your data hasn't been materialized yet (i.e., the computation hasn't run and the results aren't present in R memory).</p> <ul> <li> <p>For small results (e.g., summary stats, small tables), simply call     <code>collect()</code> or <code>as_tibble()</code> at the end of your pipeline to     materialize the data:</p> <pre><code>result &lt;- immunarch_function(idata) |&gt; collect()\n</code></pre> </li> <li> <p>For large datasets (e.g., a fully filtered <code>ImmunData</code> object),     avoid materializing unless you're sure you need all data in     memory---this could use significant RAM and slow down your workflow.</p> </li> </ul> <p>Tip: Use materialization for final summaries, plots, or tables, but keep your core ImmunData object on disk and in its lazy, efficient format for most analyses.</p> <p>You can read more about the materialization in Concepts.</p>"},{"location":"tutorials/single_cell/#working-with-data","title":"Working with data","text":""},{"location":"tutorials/single_cell/#load-airr-data","title":"Load AIRR data","text":"<p>First, we need to load sample metadata. The metadata file is a tab-separated table, where each row represents a sample (or file), and columns contain sample-level features such as <code>\"Tissue\"</code>, <code>\"Donor\"</code>, or <code>\"ImmunotherapyResponse\"</code>.</p> R <pre><code>md_file &lt;- system.file(\"extdata/single_cell\", \"metadata.tsv\", package = \"immundata\")\nmd_file\n</code></pre> <pre><code>[1] \"/home/runner/work/_temp/Library/immundata/extdata/single_cell/metadata.tsv\"\n</code></pre> <pre><code>md_table &lt;- read_metadata(md_file)\n</code></pre> <pre><code>Rows: 3 Columns: 3\n\u2500\u2500 Column specification \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nDelimiter: \"\\t\"\nchr (3): File, Tissue, Prefix\n\n\u2139 Use `spec()` to retrieve the full column specification for this data.\n\u2139 Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\u2139 Found 3/3 repertoire files from the metadata on the disk\n\n\u2714 Metadata parsed successfully\n</code></pre> <pre><code>md_table\n</code></pre> <pre><code># A tibble: 3 \u00d7 4\n  File                                                    Tissue Prefix filename\n  &lt;chr&gt;                                                   &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   \n1 /home/runner/work/_temp/Library/immundata/extdata/sing\u2026 Blood  LB6_   /home/r\u2026\n2 /home/runner/work/_temp/Library/immundata/extdata/sing\u2026 Normal LN6_   /home/r\u2026\n3 /home/runner/work/_temp/Library/immundata/extdata/sing\u2026 Tumor  LT6_   /home/r\u2026\n</code></pre> <p>The <code>\"Tissue\"</code> column defines which biological compartment (tumour, blood, or NAT) each sample comes from. We'll use it to split data into repertoires. Later in this tutorial, you'll see how to dynamically split data by other annotations, such as cell clusters from scRNA-seq.</p> <p>Next, get the file paths to the V(D)J data packaged with <code>immundata</code>:</p> R <pre><code>inp_files &lt;- paste0(system.file(\"extdata/single_cell\", \"\", package = \"immundata\"), \"/*.csv.gz\")\ninp_files\n</code></pre> <pre><code>[1] \"/home/runner/work/_temp/Library/immundata/extdata/single_cell//*.csv.gz\"\n</code></pre> <p>What is a receptor in <code>immundata</code>? A receptor is the central unit of data analysis in <code>immundata</code>. It is defined by:</p> <ul> <li>The features used for grouping (e.g., <code>cdr3</code>, <code>v_call</code>, <code>j_call</code>)</li> <li>The chains involved (e.g., <code>TRB</code> for TCR beta, or paired     <code>TRA</code>+<code>TRB</code>)</li> </ul> <p>Defining a receptor schema lets you flexibly group TCR/BCR sequences for downstream analysis and compute statistics on them.</p> <p>Here's how to define a basic single-chain receptor schema: TRB chains, grouped by both <code>cdr3</code> and <code>v_call</code> (amino acid sequence and V gene).</p> R <pre><code>schema &lt;- make_receptor_schema(features = c(\"cdr3\", \"v_call\"), chains = c(\"TRB\"))\nschema\n</code></pre> <pre><code>$features\n[1] \"cdr3\"   \"v_call\"\n\n$chains\n[1] \"TRB\"\n</code></pre> <p>If you want to use other receptor definitions, you can create and pass custom schemas to <code>read_repertoires()</code>. Below are a few examples:</p> R <pre><code># Paired-chain\nschema &lt;- make_receptor_schema(features = c(\"cdr3\", \"v_call\"), chains = c(\"TRA\", \"TRB\"))\nschema\n</code></pre> <pre><code>$features\n[1] \"cdr3\"   \"v_call\"\n\n$chains\n[1] \"TRA\" \"TRB\"\n</code></pre> <pre><code># Single-chain with \"cdr3\" only\nschema &lt;- make_receptor_schema(features = c(\"cdr3\"), chains = c(\"TRA\"))\nschema\n</code></pre> <pre><code>$features\n[1] \"cdr3\"\n\n$chains\n[1] \"TRA\"\n</code></pre> <pre><code># The most strict receptor definition\nschema &lt;- make_receptor_schema(features = c(\"cdr3\", \"v_call\", \"j_call\"), chains = c(\"TRA\", \"TRB\"))\nschema\n</code></pre> <pre><code>$features\n[1] \"cdr3\"   \"v_call\" \"j_call\"\n\n$chains\n[1] \"TRA\" \"TRB\"\n</code></pre> <p>The main entry point for loading AIRR-seq data into the <code>immunarch 1.0</code> framework is the <code>read_repertoires()</code> function from <code>immundata</code>. This function handles everything from reading raw files, to preprocessing and aggregation, to joining metadata and saving an efficient on-disk ImmunData object for reproducible analysis.</p> <p>Below, we describe the key parameters you'll want to understand:</p> <ul> <li><code>path</code> --- vector of input file paths, e.g., to AIRR TSV, 10X     CSV, or Parquet files. (You can use <code>Sys.glob()</code> to collect files.)</li> <li><code>schema</code> --- defines how receptors are grouped; typically     created with <code>make_receptor_schema()</code>.</li> <li><code>metadata</code> --- optional data frame with sample-level metadata,     read by <code>read_metadata()</code>.</li> <li><code>barcode_col</code> --- name of the column containing cell barcodes     (e.g., <code>\"barcode\"</code> for 10x single-cell data); this triggers     single-cell logic.</li> <li><code>locus_col</code> --- name of the column specifying the chain (e.g.,     <code>\"locus\"</code> for TRA/TRB distinction).</li> <li><code>umi_col</code> --- column for UMI counts (e.g., <code>\"umis\"</code>); used to     select dominant chains per barcode.</li> <li><code>preprocess</code> --- list of preprocessing steps to apply before     aggregation. The preset <code>make_default_preprocessing(\"10x\")</code> works     for standard 10x data.</li> <li><code>repertoire_schema</code> --- columns in metadata (or annotation) used     to define repertoires (e.g., <code>\"Tissue\"</code> to split by compartment).</li> </ul> <p>Here's how to use it on the packaged single-cell demo dataset:</p> R <pre><code>schema &lt;- make_receptor_schema(features = c(\"cdr3\", \"v_call\"), chains = c(\"TRB\"))\n\nidata &lt;- read_repertoires(path = inp_files, \n                          schema = schema, \n                          metadata = md_table, \n                          barcode_col = \"barcode\", \n                          locus_col = \"locus\",  # Mind that we use `locus` here because of column renaming\n                          umi_col = \"umis\",\n                          preprocess = make_default_preprocessing(\"10x\"), \n                          repertoire_schema = \"Tissue\")\n</code></pre> <pre><code>\n</code></pre> <pre><code>\u2500\u2500 Reading repertoire data \n</code></pre> <pre><code>  1. /home/runner/work/_temp/Library/immundata/extdata/single_cell/lb6.csv.gz\n</code></pre> <pre><code>  2. /home/runner/work/_temp/Library/immundata/extdata/single_cell/ln6.csv.gz\n</code></pre> <pre><code>  3. /home/runner/work/_temp/Library/immundata/extdata/single_cell/lt6.csv.gz\n</code></pre> <pre><code>\u2139 Checking if all files are of the same type\n</code></pre> <pre><code>\u2714 All files have the same extension\n</code></pre> <pre><code>\n</code></pre> <pre><code>\u2500\u2500 Renaming the columns and schemas \n</code></pre> <pre><code>\u2714 Introduced new renamed columns: locus, v_call, d_call, and j_call\n</code></pre> <pre><code>\u2714 Renaming is finished\n</code></pre> <pre><code>\n</code></pre> <pre><code>\u2500\u2500 Preprocessing the data \n</code></pre> <pre><code>  1. exclude_columns\n</code></pre> <pre><code>  2. filter_nonproductive\n</code></pre> <pre><code>\u2714 Preprocessing plan is ready\n</code></pre> <pre><code>\n</code></pre> <pre><code>\u2500\u2500 Aggregating the data to receptors \n</code></pre> <pre><code>\u2139 Found target locus: TRB. The dataset will be pre-filtered to leave chains for this locus only\n</code></pre> <pre><code>\u2139 Processing data as single-cell sequencing immune repertoires - no counts, with barcodes, chain pairing is possible\n</code></pre> <pre><code>\u2714 Execution plan for receptor data aggregation and annotation is ready\n</code></pre> <pre><code>\n</code></pre> <pre><code>\u2500\u2500 Joining the metadata table with the dataset using 'filename' column \n</code></pre> <pre><code>\u2714 Joining plan is ready\n</code></pre> <pre><code>\n</code></pre> <pre><code>\u2500\u2500 Postprocessing the data \n</code></pre> <pre><code>  1. prefix_barcodes\n</code></pre> <pre><code>\u2714 Postprocessing plan is ready\n</code></pre> <pre><code>\n</code></pre> <pre><code>\u2500\u2500 Saving the newly created ImmunData to disk \n</code></pre> <pre><code>\u2139 Writing the receptor annotation data to [/home/runner/work/_temp/Library/immundata/extdata/single_cell/immundata-lb6.csv/annotations.parquet]\n</code></pre> <pre><code>\u2139 Writing the metadata to [/home/runner/work/_temp/Library/immundata/extdata/single_cell/immundata-lb6.csv/metadata.json]\n</code></pre> <pre><code>\u2714 ImmunData files saved to [/home/runner/work/_temp/Library/immundata/extdata/single_cell/immundata-lb6.csv]\n</code></pre> <pre><code>\u2139 Reading ImmunData files from ['/home/runner/work/_temp/Library/immundata/extdata/single_cell/immundata-lb6.csv']\n</code></pre> <pre><code>\u2714 Loaded ImmunData with the receptor schema: [c(\"cdr3\", \"v_call\") and TRB]\n</code></pre> <pre><code>\u2139 Reading ImmunData files from ['/home/runner/work/_temp/Library/immundata/extdata/single_cell/immundata-lb6.csv']\n</code></pre> <pre><code>\n</code></pre> <pre><code>\u2500\u2500 Aggregating repertoires... \n</code></pre> <pre><code>\u2714 Aggregation is finished\n</code></pre> <pre><code>\n</code></pre> <pre><code>\u2500\u2500 Summary \n</code></pre> <pre><code>\u2139 Time elapsed: 5.77 secs\n</code></pre> <pre><code>\u2714 Loaded ImmunData with the receptor schema: [c(\"cdr3\", \"v_call\") and TRB]\n</code></pre> <pre><code>\u2714 Loaded ImmunData with the repertoire schema: [Tissue]\n</code></pre> <pre><code>\u2714 Loaded ImmunData with [18714] chains\n</code></pre> <pre><code>NULL\n</code></pre> <pre><code>NULL\n</code></pre> <p>The result, <code>idata</code>, is an ImmunData object --- a columnar, on-disk structure similar in spirit to Seurat or AnnData, but specifically optimized for immune repertoire analysis. You can query, annotate, or regroup it on the fly, and it remains memory efficient and fully reproducible.</p>"},{"location":"tutorials/single_cell/#load-scrnaseq-data","title":"Load scRNAseq data","text":"<p>If you're working with single-cell transcriptomics, you'll usually want to bring in cluster annotations or cell type labels. This can be done with a simple TSV table, or directly from a Seurat/AnnData object.</p> R <pre><code>cells_file &lt;- system.file(\"extdata/single_cell\", \"cells.tsv.gz\", package = \"immundata\")\ncells_file\n</code></pre> <pre><code>[1] \"/home/runner/work/_temp/Library/immundata/extdata/single_cell/cells.tsv.gz\"\n</code></pre> <pre><code>cells &lt;- readr::read_tsv(cells_file)\n</code></pre> <pre><code>Rows: 15174 Columns: 6\n\u2500\u2500 Column specification \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nDelimiter: \"\\t\"\nchr (4): barcode, ident, sample, source\ndbl (2): UMAP_1, UMAP_2\n\n\u2139 Use `spec()` to retrieve the full column specification for this data.\n\u2139 Specify the column types or set `show_col_types = FALSE` to quiet this message.\n</code></pre> <pre><code>head(cells)\n</code></pre> <pre><code># A tibble: 6 \u00d7 6\n  barcode                ident     sample source UMAP_1  UMAP_2\n  &lt;chr&gt;                  &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n1 LT6_AAACCTGAGCGTTCCG-1 8.4-Chrom LT6    Tumor   0.870  0.0175\n2 LT6_AAACCTGCATCGTCGG-1 4.4-FOS   LT6    Tumor  -3.75  -0.445 \n3 LT6_AAACCTGGTACGAAAT-1 4.6a-Treg LT6    Tumor  -2.28  -4.70  \n4 LT6_AAACCTGGTAGAGTGC-1 4.1-Trm   LT6    Tumor  -3.31  -1.28  \n5 LT6_AAACCTGGTTACGTCA-1 4.3-TCF7  LT6    Tumor  -6.93  -0.653 \n6 LT6_AAACCTGTCCGTTGCT-1 4.6b-Treg LT6    Tumor  -0.644 -5.03  \n</code></pre> <p>To visualize gene expression and link it with immune repertoires, load the expression matrix into a Seurat object. Here, we use a cached RDS to speed up the tutorial:</p> R <pre><code>url &lt;- \"https://zenodo.org/records/15604205/files/l6data.rds?download=1\"\ndest &lt;- BiocFileCache::bfcrpath(BiocFileCache::BiocFileCache(ask = FALSE), url)\n</code></pre> <pre><code>adding rname 'https://zenodo.org/records/15604205/files/l6data.rds?download=1'\n</code></pre> <pre><code>mat &lt;- readr::read_rds(dest)\n\nsdata &lt;- CreateSeuratObject(counts = mat)\n</code></pre> <pre><code>Warning: Data is of class matrix. Coercing to dgCMatrix.\n</code></pre> <pre><code>embeddings &lt;- as.matrix(cells[c(\"UMAP_1\", \"UMAP_2\")])\nrownames(embeddings) &lt;- cells$barcode\n\numap_dr &lt;- CreateDimReducObject(embeddings = embeddings, key = \"UMAP_\", assay = DefaultAssay(sdata))\n\nsdata[[\"umap\"]] &lt;- umap_dr\n\nIdents(sdata) &lt;- setNames(cells$ident, cells$barcode)\n\nDimPlot(sdata, reduction = \"umap\", order = sort(unique(cells$ident), decreasing = TRUE), label = TRUE, alpha = .5)\n</code></pre> <pre><code>Warning: `aes_string()` was deprecated in ggplot2 3.0.0.\n\u2139 Please use tidy evaluation idioms with `aes()`.\n\u2139 See also `vignette(\"ggplot2-in-packages\")` for more information.\n\u2139 The deprecated feature was likely used in the Seurat package.\n  Please report the issue at &lt;https://github.com/satijalab/seurat/issues&gt;.\n</code></pre> <p></p> <p>Tip: The <code>cells</code> object here includes precomputed UMAP coordinates to save time. In a real-world workflow, you would extract cluster labels and embeddings from your processed Seurat/AnnData object and merge them with your immune receptor data for downstream analysis.</p>"},{"location":"tutorials/single_cell/#how-to-read-other-types-of-data-bulk-single-chain-etc","title":"How to read other types of data --- bulk, single-chain, etc.","text":"<p>The <code>read_repertoires()</code> function is flexible and supports many repertoire data types and formats. Here are practical patterns for different scenarios. Use these examples as templates to adapt to your own data sources and formats.</p> <p>Note: These code blocks are for demonstration and not intended to run as part of this tutorial. Please mind the \"Tissue\": this column must be present in your data in order to create repertoires by it.</p>"},{"location":"tutorials/single_cell/#1-bulk-sequencing","title":"1. Bulk sequencing","text":"<p>For bulk AIRR-seq data, you generally don't need <code>barcode_col</code>, <code>locus_col</code>, or <code>umi_col</code>. Optionally provide <code>count_col</code> if your data includes receptor counts.</p> R <pre><code>idata &lt;- read_repertoires(path = inp_files, \n                          schema = schema, \n                          metadata = md_table, \n                          count_col = \"counts\", \n                          preprocess = make_default_preprocessing(\"airr\"), \n                          repertoire_schema = \"Tissue\")\n</code></pre>"},{"location":"tutorials/single_cell/#2-single-cell-sequencing","title":"2. Single-cell sequencing","text":"<p>For single-cell data, you'll typically need all columns (barcode, locus, UMI) for proper chain aggregation and cell assignment.</p> R <pre><code>idata &lt;- read_repertoires(path = inp_files, \n                          schema = schema, \n                          metadata = md_table, \n                          barcode_col = \"barcode\", \n                          locus_col = \"chain\", \n                          umi_col = \"umis\", \n                          preprocess = make_default_preprocessing(\"10x\"), \n                          repertoire_schema = \"Tissue\")\n</code></pre>"},{"location":"tutorials/single_cell/#3-airr-c-or-10x-genomics-format","title":"3. AIRR-C or 10x Genomics format","text":"<p>Both AIRR-C and 10x Genomics formats are supported. Pay attention to the receptor schema, locus column (<code>locus</code> or <code>chain</code>), and use the correct preset for <code>make_default_preprocessing()</code>.</p> R <pre><code>#\n# AIRR-C\n#\nschema &lt;- make_receptor_schema(features = c(\"junction_aa\", \"v_call\"), chains = \"TCRB\")\n# or\nschema &lt;- make_receptor_schema(features = c(\"cdr3_aa\", \"v_call\"), chains = \"TCRB\")\n# reminder how to read paired-chain data if needed:\nschema &lt;- make_receptor_schema(features = c(\"cdr3_aa\", \"v_call\"), chains = c(\"TCRA\", \"TCRB\"))\n\nidata &lt;- read_repertoires(path = inp_files, \n                          schema = schema, \n                          metadata = md_table,\n                          barcode_col = \"cell_id\",\n                          locus_col = \"locus\",\n                          umi_col = \"umi_count\", \n                          preprocess = make_default_preprocessing(\"airr\"), \n                          repertoire_schema = \"Tissue\")\n\n#\n# 10XGenomics\n#\n\n# This is how the original schema would look like\nschema &lt;- make_receptor_schema(features = c(\"cdr3_aa\", \"v_gene\"), chains = \"TRB\")\n\nidata &lt;- read_repertoires(path = inp_files, \n                          schema = schema, \n                          metadata = md_table, \n                          barcode_col = \"barcode\", \n                          locus_col = \"chain\", \n                          umi_col = \"umis\", \n                          preprocess = make_default_preprocessing(\"10x\"),\n                          rename_columns = NULL,\n                          repertoire_schema = \"Tissue\")\n\n# Immundata renames some columns by default to match them with AIRR-C format.\n# So we use this:\nschema &lt;- make_receptor_schema(features = c(\"cdr3\", \"v_call\"), chains = \"TRB\")\n\nidata &lt;- read_repertoires(path = inp_files, \n                          schema = schema, \n                          metadata = md_table, \n                          barcode_col = \"barcode\", \n                          locus_col = \"locus\", \n                          umi_col = \"umis\", \n                          preprocess = make_default_preprocessing(\"10x\"),\n                          repertoire_schema = \"Tissue\")\n</code></pre>"},{"location":"tutorials/single_cell/#4-reading-file-paths-from-metadata","title":"4. Reading file paths from metadata","text":"<p>If your metadata table contains file paths, you can use the special <code>path = \"&lt;metadata&gt;\"</code> argument. Specify which column in your metadata has the file paths with <code>metadata_file_col</code>.</p> R <pre><code>idata &lt;- read_repertoires(path = \"&lt;metadata&gt;\", \n                          schema = schema, \n                          metadata = md_table, \n                          barcode_col = \"barcode\", \n                          locus_col = \"locus\",\n                          umi_col = \"umis\", \n                          preprocess = make_default_preprocessing(\"10x\"),\n                          repertoire_schema = \"Tissue\")\n</code></pre>"},{"location":"tutorials/single_cell/#analyse-immune-repertoires","title":"Analyse immune repertoires","text":""},{"location":"tutorials/single_cell/#key-immune-repertoire-statistics","title":"Key immune repertoire statistics","text":"<p>A well-designed immune repertoire analysis always starts with a set of basic descriptive statistics. These help you:</p> <ul> <li>Check data quality (e.g., are all samples/cell types     well-represented?)</li> <li>Spot technical artifacts (e.g., biased V gene usage, length skews)</li> <li>Summarize diversity and composition for downstream biological or     clinical questions</li> </ul> <p>The <code>immunarch</code> package provide a family of functions, <code>airr_stats_*</code>, to quickly compute these statistics from your <code>ImmunData</code> object. To see all options or details, run <code>?airr_stats</code> in your R console.</p> <p>Currently there are three functions to compute key statistics:</p> <ol> <li> <p><code>airr_stats_chains()</code> Counts the number of chains (e.g., TRA,     TRB, IGH) per repertoire/sample. Use this for library size, capture     depth, and to check chain balance (e.g., are you missing TRA?).</p> </li> <li> <p><code>airr_stats_lengths()</code> Summarizes the CDR3 length distribution     per repertoire. Reveals if your data has technical biases, primer     effects, or biologically meaningful skews (like more long or short     clones in a disease).</p> </li> <li> <p><code>airr_stats_genes()</code> Counts the usage of V, D, or J genes per     repertoire/sample/cluster. Essential for characterizing repertoire     composition, comparing patient groups, or making features for ML     models.</p> </li> </ol>"},{"location":"tutorials/single_cell/#1a-number-of-receptors-and-barcodes-for-samples","title":"1a. Number of receptors and barcodes for samples","text":"<p>Let's start by quantifying two basic properties:</p> <ul> <li> <p>Number of unique barcodes per sample (reflects cell yield /     diversity)</p> </li> <li> <p>Number of unique receptors per sample (reflects immune diversity and     capture)</p> </li> </ul> <p>These metrics are often used as a first-line QC and as a way to detect outliers or sample-specific technical effects.</p> R <pre><code>idata_stats &lt;- airr_stats_chains(idata)\n\nidata_stats\n</code></pre> <pre><code># A tibble: 3 \u00d7 6\n  imd_repertoire_id n_barcodes n_receptors locus n_chains Tissue\n*             &lt;int&gt;      &lt;dbl&gt;       &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;chr&gt; \n1                 1       4085        3976 TRB       4085 Blood \n2                 3       7832        3962 TRB       7832 Tumor \n3                 2       6797        2950 TRB       6797 Normal\n</code></pre> <pre><code>p1 &lt;- idata_stats |&gt; vis(xval = \"Tissue\", yval = \"n_receptors\", fill = \"Tissue\", title = \"No. barcodes per sample\")\np2 &lt;- idata_stats |&gt; vis(xval = \"Tissue\", yval = \"n_receptors\", fill = \"Tissue\", title = \"No. receptors per sample\")\np1 + p2\n</code></pre> <p></p> <ul> <li> <p>Possible interpretation of results:</p> <ul> <li> <p>Large differences in barcode count may indicate sample quality     or biological differences (e.g., tumour-infiltrating T cell     abundance, malignant cells).</p> </li> <li> <p>Receptor count per sample gives a sense of diversity captured     and can flag technical dropouts or high expansion.</p> </li> </ul> </li> </ul>"},{"location":"tutorials/single_cell/#1b-number-of-receptors-and-barcodes-for-cell-clusters","title":"1b. Number of receptors and barcodes for cell clusters","text":"<p>The basic sample-level view is useful, but often you want to see how immune repertoires are distributed within cell subpopulations, e.g., by T cell cluster. With single-cell data, this is straightforward thanks to the flexible annotation model in <code>immundata</code>.</p> <p>Currently, the <code>idata</code> object holds three repertoires---one for each tissue. Let's check that:</p> R <pre><code>idata$repertoires\n</code></pre> <pre><code># A tibble: 3 \u00d7 4\n  imd_repertoire_id Tissue n_barcodes n_receptors\n              &lt;int&gt; &lt;chr&gt;       &lt;dbl&gt;       &lt;int&gt;\n1                 1 Blood        4085        3976\n2                 2 Normal       6797        2950\n3                 3 Tumor        7832        3962\n</code></pre> <p>To break down repertoire statistics by cluster, we'll annotate immune receptors with cluster labels from the single-cell data (<code>sdata</code>). Both <code>idata</code> and <code>cells</code> (and the Seurat object) share cell barcodes, so we can safely map clusters onto the immune data:</p> R <pre><code># Build a tibble: cluster label per barcode (cell)\nannot &lt;- tibble(Cluster = as.character(Idents(sdata)), barcode = names(Idents(sdata)))\n\nannot\n</code></pre> <pre><code># A tibble: 15,174 \u00d7 2\n   Cluster   barcode               \n   &lt;chr&gt;     &lt;chr&gt;                 \n 1 8.4-Chrom LT6_AAACCTGAGCGTTCCG-1\n 2 4.4-FOS   LT6_AAACCTGCATCGTCGG-1\n 3 4.6a-Treg LT6_AAACCTGGTACGAAAT-1\n 4 4.1-Trm   LT6_AAACCTGGTAGAGTGC-1\n 5 4.3-TCF7  LT6_AAACCTGGTTACGTCA-1\n 6 4.6b-Treg LT6_AAACCTGTCCGTTGCT-1\n 7 8.2-Tem   LT6_AAACCTGTCGCCTGTT-1\n 8 4.1-Trm   LT6_AAACCTGTCTCCGGTT-1\n 9 4.6a-Treg LT6_AAACGGGAGGTAGCTG-1\n10 8.3a-Trm  LT6_AAACGGGAGTTATCGC-1\n# \u2139 15,164 more rows\n</code></pre> <pre><code># Annotate ImmunData by barcode, then regroup repertoires by Tissue *and* Cluster\nidata &lt;- annotate_barcodes(idata, annot, \"barcode\")\nidata &lt;- agg_repertoires(idata, c(\"Tissue\", \"Cluster\"))\n\n# Now each repertoire is a unique (Tissue, Cluster) pair\nidata$repertoires\n</code></pre> <pre><code># A tibble: 51 \u00d7 5\n   imd_repertoire_id Tissue Cluster     n_barcodes n_receptors\n               &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;            &lt;dbl&gt;       &lt;int&gt;\n 1                 1 Blood  8.2-Tem            134         123\n 2                 2 Blood  4.3-TCF7          1054        1049\n 3                 3 Blood  4.6a-Treg          208         203\n 4                 4 Blood  8.3c-Trm            53          53\n 5                 5 Blood  8.6-KLRB1           75          71\n 6                 6 Blood  8.5-Mitosis         43          42\n 7                 7 Blood  8.3b-Trm            32          31\n 8                 8 Normal 3.1-MT             248         183\n 9                 9 Normal &lt;NA&gt;               680         420\n10                10 Tumor  3.1-MT              93          74\n# \u2139 41 more rows\n</code></pre> <p>Now is a good time to save a snapshot. You've run several heavy steps and defined your working dataset: tissue annotations, cluster labels, and more. A snapshot freezes this state for reproducibility. Learn why in the Concepts \u2192 Immutability.</p> <p>You can create snapshot via <code>write_immundata</code> function that will save the data on disk, and then load the snapshot so you can work with the newly created data.</p> R <pre><code>idata &lt;- write_immundata(idata, \"./immundata-files\")\n</code></pre> <pre><code>\u2139 Writing the receptor annotation data to [./immundata-files/annotations.parquet]\n</code></pre> <pre><code>\u2139 Writing the metadata to [./immundata-files/metadata.json]\n</code></pre> <pre><code>\u2714 ImmunData files saved to [./immundata-files]\n</code></pre> <pre><code>\u2139 Reading ImmunData files from ['./immundata-files']\n</code></pre> <pre><code>\u2714 Loaded ImmunData with the receptor schema: [c(\"cdr3\", \"v_call\") and TRB]\n</code></pre> <pre><code>\u2714 Loaded ImmunData with the repertoire schema: [Tissue and Cluster]\n</code></pre> <p>Now let's recompute and visualize statistics at this new level of granularity:</p> R <pre><code>idata_stats &lt;- airr_stats_chains(idata)\n\nidata_stats\n</code></pre> <pre><code># A tibble: 51 \u00d7 7\n   imd_repertoire_id n_barcodes n_receptors locus n_chains Tissue Cluster    \n *             &lt;int&gt;      &lt;dbl&gt;       &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;      \n 1                 1        134         123 TRB        134 Blood  8.2-Tem    \n 2                 2       1054        1049 TRB       1054 Blood  4.3-TCF7   \n 3                 3        208         203 TRB        208 Blood  4.6a-Treg  \n 4                 4         53          53 TRB         53 Blood  8.3c-Trm   \n 5                 5         75          71 TRB         75 Blood  8.6-KLRB1  \n 6                 6         43          42 TRB         43 Blood  8.5-Mitosis\n 7                 7         32          31 TRB         32 Blood  8.3b-Trm   \n 8                 8        248         183 TRB        248 Normal 3.1-MT     \n 9                 9        680         420 TRB        680 Normal &lt;NA&gt;       \n10                10         93          74 TRB         93 Tumor  3.1-MT     \n# \u2139 41 more rows\n</code></pre> <pre><code># Barcodes and receptors per tissue, filled by cluster\np1 &lt;- idata_stats |&gt; vis(xval = \"Tissue\", yval = \"n_receptors\", fill = \"Cluster\", title = \"No. barcodes per sample\")\np2 &lt;- idata_stats |&gt; vis(xval = \"Tissue\", yval = \"n_receptors\", fill = \"Cluster\", title = \"No. receptors per sample\")\np1 / p2\n</code></pre> <p></p> <p>This provides a detailed view of which clusters dominate each tissue. To focus even further on cluster differences across tissues, group and plot by cluster:</p> R <pre><code>idata_stats |&gt; vis(xval = \"Cluster\", fill = \"Tissue\")\n</code></pre> <p></p> <p>Note: You may see NAs, or an unexpectedly high number of receptors per barcode (especially in tumor samples), if you analyze only the \"TRB\" chain. This happens because a single barcode can have multiple TRB contigs, due to technical or biological reasons (e.g., malignant cells). Switching to a paired-chain (TRA + TRB) schema forces <code>immundata</code> to collapse these into a single receptor pair per barcode, producing a clearer one-cell-one-receptor relationship and making cluster-level summaries more interpretable.</p> <p>Homework for you: try running this analysis with a paired-chain schema (see earlier examples). The rest of your code will remain unchanged --- that's the power of decoupling data structure (<code>immundata</code> data structure) from analysis logic (<code>immunarch</code> functions)!</p> <p>We can also normalize by the total number of barcodes per tissue for fairer cross-tissue comparison:</p> R <pre><code>idata_stats2 &lt;- idata_stats |&gt; mutate(.by = Tissue, TissueSize = sum(n_barcodes)) |&gt; mutate(n_barcodes_div = n_barcodes / TissueSize)\nidata_stats2\n</code></pre> <pre><code># A tibble: 51 \u00d7 9\n   imd_repertoire_id n_barcodes n_receptors locus n_chains Tissue Cluster    \n               &lt;int&gt;      &lt;dbl&gt;       &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;      \n 1                 1        134         123 TRB        134 Blood  8.2-Tem    \n 2                 2       1054        1049 TRB       1054 Blood  4.3-TCF7   \n 3                 3        208         203 TRB        208 Blood  4.6a-Treg  \n 4                 4         53          53 TRB         53 Blood  8.3c-Trm   \n 5                 5         75          71 TRB         75 Blood  8.6-KLRB1  \n 6                 6         43          42 TRB         43 Blood  8.5-Mitosis\n 7                 7         32          31 TRB         32 Blood  8.3b-Trm   \n 8                 8        248         183 TRB        248 Normal 3.1-MT     \n 9                 9        680         420 TRB        680 Normal &lt;NA&gt;       \n10                10         93          74 TRB         93 Tumor  3.1-MT     \n# \u2139 41 more rows\n# \u2139 2 more variables: TissueSize &lt;dbl&gt;, n_barcodes_div &lt;dbl&gt;\n</code></pre> <pre><code>idata_stats2 |&gt; vis(xval = \"Cluster\", y = \"n_barcodes_div\", fill = \"Tissue\", title = \"No. barcodes per sample\")\n</code></pre> <p></p> <ul> <li> <p>Possible interpretation:</p> <ul> <li> <p>You may observe patterns like more Tregs in tumor, more Trm in     NAT, etc.</p> </li> <li> <p>Remember: normalization lets you compare proportions across     samples, but absolute numbers (e.g., total cells per tissue) are     influenced by capture and sequencing depth.</p> </li> </ul> </li> </ul>"},{"location":"tutorials/single_cell/#2a-global-gene-usage","title":"2a. Global gene usage","text":"<p>One of the most informative immune repertoire features is V(D)J gene segment usage. Shifts in gene usage can reveal biological signatures (e.g., enrichment of certain V genes in tumor-infiltrating clones), technical artifacts, or repertoire biases. Let's create a heatmap showing the frequency of each V gene segment across all cluster-tissue combinations. This gives a compact, bird's-eye view of usage patterns and potential \"hotspots\" of expansion.</p> R <pre><code>gene_usage_full &lt;- airr_stats_genes(\n  idata,\n  gene_col = \"v_call\",\n  level    = \"receptor\"\n)\n\ngene_usage_full |&gt; vis(col = c(\"Cluster\", \"Tissue\"))\n</code></pre> <p></p>"},{"location":"tutorials/single_cell/#2b-most-overrepresented-v-gene-segments","title":"2b. Most overrepresented V gene segments","text":"<p>As you can see, the broad overview is not very straightforward to understand. We can focus on most strong \"signals\" from the data: which V genes are most used across all samples and repertoires? This can help spot outlier samples, overall biases, or dominant clonotypes.</p> R <pre><code># Compute V gene usage for all repertoires (by receptor count, split by tissue if present)\ngene_usage_full &lt;- airr_stats_genes(\n  idata,\n  gene_col = \"v_call\",\n  level    = \"receptor\"\n)\n\ntop_n &lt;- 10\n\ntop_vgenes &lt;- gene_usage_full |&gt; \n  group_by(Tissue, v_call) |&gt; \n  summarize(n = sum(n), .groups = \"drop\") |&gt; \n  group_by(Tissue) |&gt; \n  slice_max(order_by = n, n = top_n) |&gt; \n  ungroup()\n\n# Collect the *union* of all top genes across tissues\ntop_gene_set &lt;- unique(top_vgenes$v_call)\n\n# Filter to only these V genes for the heatmap (across all clusters and tissues)\nusage_focus &lt;- gene_usage_full |&gt; \n  filter(v_call %in% top_gene_set)\n\nusage_focus |&gt; vis(col = c(\"Cluster\", \"Tissue\"))\n</code></pre> <p></p>"},{"location":"tutorials/single_cell/#2c-cluster-specific-v-gene-distribution","title":"2c. Cluster-specific V gene distribution","text":"<p>We can do pretty much the same if there are specific clusters we are interested in specifically:</p> R <pre><code># We use special functions from duckdb to filter clusters of interest\ngene_usage_full &lt;- idata |&gt; \n  filter_immundata(dd$regexp_matches(Cluster, \"Treg|Trm\")) |&gt; \n  airr_stats_genes(\n    gene_col = \"v_call\",\n    level    = \"receptor\"\n  )\n\ntop_n &lt;- 10\n\ntop_vgenes &lt;- gene_usage_full |&gt; \n  group_by(Tissue, v_call) |&gt; \n  summarize(n = sum(n), .groups = \"drop\") |&gt; \n  group_by(Tissue) |&gt; \n  slice_max(order_by = n, n = top_n) |&gt; \n  ungroup()\n\n# Collect the *union* of all top genes across tissues\ntop_gene_set &lt;- unique(top_vgenes$v_call)\n\n# Filter to only these V genes for the heatmap (across all clusters and tissues)\nusage_focus &lt;- gene_usage_full |&gt; \n  filter(v_call %in% top_gene_set)\n\nusage_focus |&gt; vis(col = c(\"Cluster\", \"Tissue\"))\n</code></pre> <p></p> <ul> <li> <p>The rows are the most frequent V genes (union of top N per tissue).</p> </li> <li> <p>The columns represent every observed (Cluster, Tissue) combination.</p> </li> <li> <p>Color shows how often each V gene appears in each group.</p> </li> </ul>"},{"location":"tutorials/single_cell/#3a-cdr3-length-distribution-for-the-full-dataset","title":"3a. CDR3 length distribution for the full dataset","text":"<p>The CDR3 length distribution is a key QC and biological fingerprint of an immune repertoire. It can reveal technical artifacts (e.g., primer/UMI bias), repertoire selection, or expansion of unusual clones in disease states.</p> <p>We can compute and visualize CDR3 length distributions across all tissues and clusters.</p> R <pre><code># Compute CDR3 length stats for all repertoires (default is cdr3_aa)\nlength_stats &lt;- airr_stats_lengths(\n  idata,\n  seq_col = \"cdr3\"\n)\n\n# Plot: density of CDR3 lengths by tissue\nggplot(length_stats, aes(x = seq_len, y = pct, color = Tissue)) +\n  geom_line(stat = \"identity\", linewidth = 1.2) +\n  facet_wrap(~ Tissue, scales = \"free_y\") +\n  ggtitle(\"CDR3 length distribution by tissue\") +\n  xlab(\"CDR3 length (amino acids)\") +\n  ylab(\"% receptors\") +\n  ggsci::scale_color_locuszoom()\n</code></pre> <p></p>"},{"location":"tutorials/single_cell/#3b-cdr3-length-distribution-for-the-selected-clusters","title":"3b. CDR3 length distribution for the selected clusters","text":"<p>You can also zoom in on clusters of interest (e.g., Trm, Treg) for fine-grained analysis.</p> R <pre><code># Choose clusters to display\nselected_clusters &lt;- c(\"Trm\", \"Treg\")\n\nlength_stats_sel &lt;- length_stats %&gt;%\n  filter(grepl(\"Trm|Treg\", Cluster))\n\nggplot(length_stats_sel, aes(x = seq_len, y = pct, color = Tissue)) +\n  geom_line(stat = \"identity\", linewidth = 1.2) +\n  facet_wrap(~ Cluster, scales = \"free_y\") +\n  ggtitle(\"CDR3 length distribution in Trm and Treg clusters\") +\n  xlab(\"CDR3 length (amino acids)\") +\n  ylab(\"% receptors\") +\n  ggsci::scale_color_locuszoom()\n</code></pre> <p></p> <ul> <li> <p>Possible interpretation:</p> <ul> <li>Most TCR/BCR repertoires peak at 13--15 amino acids for CDR3,     but expansions, artifacts, or certain subsets may show longer or     shorter tails.</li> <li>Comparing distributions across tissues/clusters can highlight     biologically relevant skewing (e.g., enrichment of unusually     long or short CDR3s in tumors).</li> </ul> </li> </ul>"},{"location":"tutorials/single_cell/#clonality-quantifying-immune-expansion","title":"Clonality: quantifying immune expansion","text":"<p>Immune repertoires are rarely flat. Certain T or B cell receptors expand dramatically in response to infection, cancer, or autoimmunity. Quantifying clonality lets you:</p> <ul> <li>Detect immune responses (\"public\" expansions or tumor-infiltrating     clones)</li> <li>Compare the expansion across samples, tissues, or cell states</li> <li>Identify technical problems (e.g., overamplification)</li> </ul> <p>Currently there are three ways to summarize clonality:</p> <ol> <li><code>airr_clonality_line</code> Rank--abundance plots Shows how steep     the line of receptor abundances is.</li> <li><code>airr_clonality_prop</code> Clonal space partitions by proportion     Shows how much space is occupied by hyperexpanded, large, or rare     clones.</li> <li><code>airr_clonality_rank</code> Clonal space partitions by rank Shows     how much space is occupied by receptors from different bins: top-10     most abundance, top-100 most abundant, etc.</li> </ol> <p>Note: These functions are repertoire-level statistics. For annotating <code>ImmunData</code> with the per-receptor information of clonality, e.g., which receptors are hyperexpanded, to visualize them later on UMAP, use the receptor-level function family <code>annotate_clonality</code>. We will discuss them in the sections below.</p>"},{"location":"tutorials/single_cell/#1-rank-abundance","title":"1. Rank abundance","text":"<p>A rank abundance plot shows, for each sample (or group), how cell counts drop as you go from the most to least abundant clone. In other words, how steep the clonal hierarchy is.</p> <ul> <li>Steep curves: few highly expanded clones dominate (e.g., tumor     or antigen-driven response)</li> <li>Flat curves: repertoire is diverse and even</li> </ul> R <pre><code># Compute the abundance (cell/UMI count) for top 1000 clones per repertoire\nclonal_line &lt;- airr_clonality_line(\n  idata,\n  limit = 1000\n)\n\n# Plot: each line is a sample, colored by tissue\nggplot(clonal_line, aes(x = index, y = imd_count, color = Tissue, group = imd_repertoire_id)) +\n  geom_line(alpha = 0.7) +\n  scale_x_log10() +\n  scale_y_log10() +\n  ggtitle(\"Rank\u2013abundance: Top 1000 clones per repertoire\") +\n  xlab(\"Clone rank (1 = most abundant)\") +\n  ylab(\"Cell count (log10 scale)\") +\n  ggsci::scale_color_locuszoom()\n</code></pre> <p></p> <ul> <li>Possible interpretation:<ul> <li>If you see a sharp drop (\"hockey stick\" curve), a handful of     clones dominate. This is often a hallmark of strong     antigen-driven selection.</li> <li>Flatter curves are typically seen in healthy tissues or naive     compartments, reflecting higher diversity.</li> </ul> </li> </ul>"},{"location":"tutorials/single_cell/#2-clonal-space-partitioning","title":"2. Clonal space partitioning","text":"<p>Sometimes, you want to summarize clonal expansion in a single barplot splitting each repertoire into bins by abundance. For example:</p> <ul> <li>\"Hyperexpanded\": clones with \u22651% of all cells</li> <li>\"Large\": \u22650.1%, etc.</li> <li>\"Rare\": all the way down to singletons</li> </ul> <p>This lets you instantly compare, for example, how \"oligoclonal\" each tissue or cluster is. In other words, this helps you explore how much \"hyperexpanded\" is.</p> R <pre><code>clonal_prop &lt;- airr_clonality_prop(idata)\n\n# Plot: what fraction of the repertoire falls into each clonal bin\nggplot(clonal_prop, aes(x = Tissue, y = occupied_prop, fill = clonal_prop_bin)) +\n  geom_col(position = \"fill\") +\n  ggtitle(\"Fraction of repertoire: hyperexpanded, large, rare clones\") +\n  ylab(\"Fraction of cells\") +\n  xlab(\"Tissue\") +\n  ggsci::scale_fill_locuszoom() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))\n</code></pre> <p></p> <ul> <li>Possible interpretation:<ul> <li>A tumor-infiltrated sample often shows a big block of     \"hyperexpanded\" (or \"large\") clones, reflecting a focused immune     response or selection.</li> <li>Healthy tissues or controls should have more \"rare\" or \"small\"     clones---indicating diverse, unperturbed immunity.</li> </ul> </li> </ul> <p>You can repeat this for cell clusters, different patients, or experimental groups simply by re-aggregating repertoires (see earlier sections).</p>"},{"location":"tutorials/single_cell/#3-clonal-rank-bins","title":"3. Clonal rank bins","text":"<p>Useful for fine-grained analysis: how much of the repertoire is explained by the top 10, top 100, or top 1000 clones?</p> R <pre><code>clonal_rank &lt;- airr_clonality_rank(\n  idata,\n  bins = c(10, 100, 1000)\n)\n\nggplot(clonal_rank, aes(x = Tissue, y = occupied_prop, fill = as.factor(clonal_rank_bin))) +\n  geom_col(position = \"fill\") +\n  ggtitle(\"Fraction of repertoire: top-10, top-100, top-1000\") +\n  ylab(\"Fraction of cells\") +\n  xlab(\"Tissue\") +\n  ggsci::scale_fill_locuszoom() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))\n</code></pre> <p></p> <p>Tip: You can also plot this as a heatmap, line plot, or grouped barplot as needed.</p> <ul> <li> <p>Best practices &amp; notes:</p> <ul> <li>Always compare clonality to other diversity measures (Shannon,     Simpson, etc.) for a complete picture.</li> <li>Technical artifacts (PCR/UMI bias) can sometimes mimic true     expansion---use biological controls and inspect barcodes/cell     counts per clone if unsure.</li> <li>When using clusters or annotations, make sure you have enough     cells per group for the statistics to be meaningful.</li> </ul> </li> </ul>"},{"location":"tutorials/single_cell/#diversity-how-rich-and-even-are-your-repertoires","title":"Diversity: how rich and even are your repertoires?","text":"<p>True immune diversity is about more than just the number of unique sequences. It's about the balance of clone sizes, the richness of the repertoire, and whether a handful of clones dominate or if the population is broad and even. Measuring diversity helps you:</p> <ul> <li>Compare immune health or perturbation across tissues, patients, or     clusters</li> <li>Spot narrowing (loss of diversity) in disease, aging, or after     therapy</li> <li>Select features for machine learning and biomarker discovery</li> </ul> <p>Diversity is the flip side of clonality:</p> <ul> <li>Clonality highlights enrichment --- how much your repertoire     is dominated by overexpanded (\"clonal\") receptors.</li> <li>Diversity measures the overall heterogeneity and evenness of     the repertoire --- are many clones present, and are they well     balanced, or is the repertoire narrow?</li> </ul> <p>In practical terms:</p> <ul> <li>High diversity = many unique, somehow similarly sized clones;     typical of healthy, naive, or unperturbed immunity.</li> <li>Low diversity = few clones dominate (high clonality); seen in     strong immune responses, cancer, infection, or technical issues.</li> </ul> <p><code>immunarch</code> provides multiple diversity estimators, each with its own interpretation. To see all options or details, run <code>?airr_diversity</code> in your R console. Supported methods are:</p> <ol> <li> <p><code>airr_diversity_dxx()</code> Coverage diversity --- D50, D20, D80...     \"How many top clones do you need to cover X% of all cells?\" Small     D50 = a few clones dominate (low diversity); large D50 = highly     polyclonal.</p> </li> <li> <p><code>airr_diversity_chao1()</code> A nonparameteric asymptotic estimator     of species richness (number of species in a population). One of the     most used methods for estimating immune repertoire diversity.</p> </li> <li> <p><code>airr_diversity_shannon()</code> Shannon entropy --- a gold     standard, evenness-aware metric for diversity. Higher values = more     diverse and even repertoire.</p> </li> <li> <p><code>airr_diversity_pielou()</code> Pielou's evenness --- entropy     normalized by clone count, ranges [0, 1]. Use when comparing     repertoires of very different sizes.</p> </li> <li> <p><code>airr_diversity_index()</code> Hill number (q=1) --- the \"effective     number\" of clones, combines richness and evenness. Intuitive and     robust: \"How many equally frequent clones would give this entropy?\"</p> </li> <li> <p><code>airr_diversity_hill()</code> Hill diversity profile (q=0,1,2, ...)     Powerful for exploring sensitivity to rare vs.\u00a0abundant clones.</p> <ul> <li>q=0: just unique count (\"richness\")</li> <li>q=1: entropy-based (exp(Shannon))</li> <li>q=2: Simpson's index (abundant clones dominate)</li> </ul> </li> </ol> R <pre><code># 1. Coverage diversity \u2014 D50: how many clones cover 50% of the repertoire?\nd50 &lt;- airr_diversity_dxx(idata, perc = 50)\np1 &lt;- d50 |&gt; vis()\n\n# 3. Chao1 \u2014 non-parametric estimator of species richness (number of unique receptors)\nchao &lt;- airr_diversity_chao1(idata)\np2 &lt;- chao |&gt; vis(fill = \"Tissue\")\n\n# 3. Shannon entropy \u2014 classical diversity (higher = more even)\nshannon &lt;- airr_diversity_shannon(idata)\np3 &lt;- shannon |&gt; vis(xval = \"Cluster\")\n\n# 4. Pielou's evenness (normalized entropy, 0 = dominated, 1 = perfectly even)\npielou &lt;- airr_diversity_pielou(idata)\np4 &lt;- pielou |&gt; vis(xval = \"Tissue\")\np5 &lt;- pielou |&gt; vis(facet = \"Tissue\", fill = \"Cluster\", dir = \"v\")\n\n# 5. Hill number (q=1): the \u201ceffective number of clones\u201d\nhill1 &lt;- airr_diversity_index(idata)\n\n# 6. Hill diversity profile (q=0, 1, 2, ...)\nhill_profile &lt;- airr_diversity_hill(idata, q = c(0, 1, 2))\n\np1\n</code></pre> <p></p> <pre><code>p2\n</code></pre> <p></p> <pre><code>p3\n</code></pre> <p></p> <pre><code>p4\n</code></pre> <p></p> <pre><code>p5\n</code></pre> <p></p>"},{"location":"tutorials/single_cell/#public-receptor-indices-quantifying-repertoire-overlap","title":"Public receptor indices: quantifying repertoire overlap","text":"<p>In immunology, public receptors are TCRs or BCRs that appear in multiple individuals or samples, suggesting convergent responses to shared antigens, or technical \"publicity\" due to biases. Measuring the overlap between repertoires helps you:</p> <ul> <li>Find biologically meaningful \"public\" clonotypes</li> <li>QC for sample swap, cross-contamination, or replicate similarity</li> <li>Compare cohort similarity or donor-sharing at scale</li> </ul> <p><code>immunarch</code> provides fast tools for quantifying this:</p> <ul> <li> <p><code>airr_public_intersection()</code> Count of shared unique receptors     between each repertoire pair. Use for overlap heatmaps, or to check     how much two samples have in common.</p> </li> <li> <p><code>airr_public_jaccard()</code> Jaccard similarity of receptor sets     between repertoires (\u2060|A\u2229B| / |A\u222aB|\u2060). This normalizes for     differences in sample size---great for comparing across experiments     or donors.</p> </li> </ul> <p>For full options and details, run <code>?airr_public</code> in your R console.</p> <p>Let's compute overlap and Jaccard similarity between all pairs of repertoires (e.g., samples, tissues, clusters):</p> R <pre><code># 1. Count of shared receptors: intersection matrix\nm_pub &lt;- airr_public_intersection(idata)\n\n# 2. Jaccard similarity: size-normalized matrix\nm_jac &lt;- airr_public_jaccard(idata)\n\nm_pub |&gt; vis()\n</code></pre> <p></p> <pre><code>m_jac |&gt; vis()\n</code></pre> <p></p> <p>Possible interpretation:</p> <ul> <li> <p>Diagonal: total unique receptors per repertoire (\"richness\").</p> </li> <li> <p>Off-diagonal: degree of sharing.</p> <ul> <li>High off-diagonal = strong overlap (potentially \"public\" clones,     or replicates).</li> <li>Low off-diagonal = private repertoires (most unique to each     sample).</li> </ul> </li> </ul> <p>Use Jaccard for size-normalized comparison, especially across different tissues, donors, or experiments.</p> <p>We found that there are some overlapped receptors. But what are those public receptors? The next section will help us extract them from the data and analyse.</p>"},{"location":"tutorials/single_cell/#discover-and-annotate-immune-receptors","title":"Discover and annotate immune receptors","text":"<p>Please mind that that sections are below are still work in progress.</p> <p>All <code>airr_*</code> functions work on the repertoire-level and return repertoire-level statistics.</p> <p>All <code>receptor_*</code> functions work on the receptor-level and return filtered <code>ImmunData</code>-s.</p> <p>All <code>annotate_*</code> functions work on the receptor-level and return annotated <code>ImmunData</code>-s, preserving the input data and adding additional columns for annotations.</p>"},{"location":"tutorials/single_cell/#annotating-receptors-by-clonality","title":"Annotating receptors by clonality","text":"<p>This subsection was composed rather quickly to cover a highly-requested feature. More polished version will be available on the next release</p> <p>Clonality tells us how overabundant a receptor is inside a repertoire. Here we add a label per receptor, then pass a single label per cell to Seurat for easy plotting on UMAP.</p> <p>You can choose one of two simple rules:</p> <ul> <li>By proportion (recommended to start): bins like Hyperexpanded,     Large, ... based on the receptor's <code>proportion</code> within the     repertoire.</li> <li>By rank: bins by the receptor's rank (top 10, top 100, ...)     within the repertoire.</li> </ul> <p>Both helpers keep your data intact and add new columns to <code>ImmunData</code>.</p> <p>Note: Thresholds are heuristics. They are good defaults, not universal truths. Adjust them to your study.</p> R <pre><code>idata &lt;- annotate_clonality_prop(idata)\n\nsdata &lt;- annotate_seurat(idata, sdata, cols = \"clonal_prop_bin\")\n\nSeurat::DimPlot(sdata, reduction = \"umap\", group.by = \"clonal_prop_bin\", shuffle = TRUE)\n</code></pre> <p></p> <pre><code>idata &lt;- annotate_clonality_rank(idata)\n\nsdata &lt;- annotate_seurat(idata, sdata, cols = \"clonal_rank_bin\")\n\nSeurat::DimPlot(sdata, reduction = \"umap\", group.by = \"clonal_rank_bin\", shuffle = TRUE)\n</code></pre> <p></p>"},{"location":"tutorials/single_cell/#other-sections","title":"Other sections","text":"<p>The following sections are under construction as I currently develop the receptor-level analysis functionality. I plan to release the most commonly used functions in November 2025. Monitor my LinkedIn and GitHub for news and updates.</p> <p>The planned topics are:</p> <ul> <li> <p>use external databases to find CMV-specific receptors in the input     repertoires</p> </li> <li> <p>track specific CMV-related receptors through different tissues and     highlight them on single-cell UMAP</p> </li> <li> <p>analyse and plot counts of specific receptors vs.\u00a0expression of     genes of interest</p> </li> <li> <p>public repertoire analysis - discover receptors which are     suspiciously overabundant in one groups of repertoires in contrast     to another groups of repertoires (e.g., control vs condition to     search for TIL or antigen-specific receptors)</p> </li> <li> <p>all of above but using levenshtein-based similarity instead of exact     matches</p> </li> </ul>"},{"location":"tutorials/single_cell/#wip-analyse-subgroups-of-receptors-of-interest","title":"[WIP] Analyse subgroups of receptors of interest","text":"<p>This is section is too under constructions. Planned content:</p> <ul> <li> <p>discover receptors of interest, e.g., CMV-specific</p> </li> <li> <p>run analysis to compare sum/avg abundance of such receptors between     groups to measure the level of signal</p> </li> </ul>"},{"location":"tutorials/single_cell/#wip-conclusion","title":"[WIP] Conclusion","text":"<p>No spoilers. :-)</p>"},{"location":"tutorials/single_cell/#testing-zone","title":"Testing zone","text":"<p>Small test here and there, don't mind me, nothing suspicious is going on here...</p> RPython <pre><code>c(1,2,3) |&gt; sum()\n</code></pre> <pre><code>max([1,2,3])\n</code></pre> <p>Text block as a divider...</p> RPython <pre><code>c(1,2,3) |&gt; sum()\n</code></pre> <pre><code>[1] 6\n</code></pre> <pre><code>max([1,2,3])\n</code></pre> <pre><code>3\n</code></pre>"},{"location":"zh/concepts/basics/aggregation/","title":"\u805a\u5408\uff1a\u5b9a\u4e49\u53d7\u4f53\uff08receptors\uff09\u4e0e\u53d7\u4f53\u5e93\uff08repertoires\uff09","text":"<p>\u7b2c\u4e8c\u4e2a\u5173\u952e\u6982\u5ff5\u662f\u5982\u4f55\u5b9a\u4e49\u4ec0\u4e48\u662f\u53d7\u4f53\u548c\u53d7\u4f53\u5e93\u3002\u5f53\u4f60\u7684\u6570\u636e\u6765\u81ea\u50cf Cell Ranger \u8fd9\u6837\u7684 AIRR \u7ec4\u88c5\u5de5\u5177\u65f6\uff0c\u4f60\u4f1a\u5f97\u5230\u8bb8\u591a\u72ec\u7acb\u7684 V(D)J \u94fe\uff08chains\uff09\u3002 \u4f46\u5927\u591a\u6570\u95ee\u9898\u662f\u5173\u4e8e\u53d7\u4f53\uff08receptors\uff09\uff08\u4f8b\u5982\uff0c\u201c\u7b5b\u9009\u4f9b\u4f53 A \u5728\u7b2c 30 \u5929\u7684\u6240\u6709\u53d7\u4f53\u201d\uff09\u6216\u53d7\u4f53\u5e93\uff08repertoires\uff09\uff08\u4f8b\u5982\uff0c\u201c\u514d\u75ab\u6cbb\u7597\u5e94\u7b54\u8005\u4e0e\u975e\u5e94\u7b54\u8005\u5728\u57fa\u56e0\u4f7f\u7528\u65b9\u9762\u6709\u4ec0\u4e48\u5dee\u5f02\uff1f\u201d\uff09\u3002</p> <p>\u6362\u53e5\u8bdd\u8bf4\uff0c\u8fd9\u4e2a\u6982\u5ff5\u80cc\u540e\u7684\u5047\u8bbe\u662f\uff1a\u7814\u7a76\u8005\u5728\u94fe\uff08\u91cd\u6392\uff09\u5c42\u9762\u5de5\u4f5c\uff0c\u4f46\u5728\u53d7\u4f53\u4e0e\u53d7\u4f53\u5e93\u5c42\u9762\u601d\u8003\u3002<code>immundata</code> \u901a\u8fc7\u53d7\u63a7\u805a\u5408\uff08controlled aggregation\uff09\u5e2e\u52a9\u4f60\u4ece\u539f\u59cb\u94fe\u8dc3\u8fc1\u5230\u8fd9\u4e9b\u66f4\u9ad8\u5c42\u6b21\u7684\u5bf9\u8c61\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u4f60\u5148\u5236\u5b9a\u6e05\u6670\u7684\u89c4\u5219\u6765\u8bf4\u660e\u5982\u4f55\u628a\u94fe\u5408\u6210\u4e3a\u53d7\u4f53\u3001\u518d\u628a\u53d7\u4f53\u5408\u6210\u4e3a\u53d7\u4f53\u5e93\uff0c\u8f6f\u4ef6\u4f1a\u636e\u6b64\u6267\u884c\u3002</p>"},{"location":"zh/concepts/basics/aggregation/#agg_receptors","title":"<code>agg_receptors()</code>: \u5b9a\u4e49\u201c\u4e00\u4e2a\u53d7\u4f53\u201d\u7684\u542b\u4e49","text":"<p>\u4f7f\u7528 <code>immundata::agg_receptors()</code> \u6765\u51b3\u5b9a\u5728\u4f60\u7684\u7814\u7a76\u4e2d\u5982\u4f55\u6784\u5efa\u53d7\u4f53\uff0c\u5373\u5728\u4f60\u7684\u7814\u7a76\u4e2d\u4e00\u4e2a\u53d7\u4f53\u610f\u5473\u7740\u4ec0\u4e48\u3002</p> <ol> <li>\u5148\u9009\u62e9\u4e00\u4e2aschema\uff08\u914d\u65b9\uff09\u3002\u4f8b\u5982\uff1a</li> <li>\u4e0d\u5e26 V \u57fa\u56e0\u7247\u6bb5\u7684\u5355\u94fe\u3002</li> <li>\u5e26 V \u57fa\u56e0\u7247\u6bb5\u7684\u5355\u94fe\u3002</li> <li>\u5c06\u5171\u4eab\u540c\u4e00\u6761\u5f62\u7801\u4e14\u5177\u6709 \u03b1 \u4e0e \u03b2 \u4f4d\u70b9\u7684\u94fe\u914d\u5bf9\u3002</li> <li>\u5c06\u6bcf\u4e2a IGH \u4e0e\u5177\u6709\u76f8\u540c CDR3 \u6c28\u57fa\u9178\u5e8f\u5217\u7684 IGL \u8fdb\u884c\u5339\u914d\u3002</li> <li>\u8be5\u51fd\u6570\u4f1a\u91cd\u5efa\u6216\u91cd\u65b0\u805a\u5408\u6570\u636e\u5e76\u8fd4\u56de\u4e00\u4e2a\u65b0\u7684 <code>ImmunData</code> \u5bf9\u8c61\u3002\u5e95\u5c42\u6570\u636e\u4e0d\u4f1a\u88ab\u4fee\u6539\uff1b\u4f60\u53ea\u662f\u83b7\u5f97\u4e86\u4e00\u4e2a\u6570\u636e\u7684\u65b0\u201c\u89c6\u56fe\u201d\u3002</li> <li>\u6bcf\u4e2a\u53d7\u4f53\u90fd\u4f1a\u5f97\u5230\u4e00\u4e2a\u7a33\u5b9a\u7684 ID\uff0c\u5e76\u4fdd\u7559\u5230\u5176\u539f\u59cb\u94fe\u4e0e\u6761\u5f62\u7801\u7684\u94fe\u63a5\u3002</li> <li>\u5982\u679c\u4f60\u4e4b\u540e\u66f4\u6539\u4e86\u53d7\u4f53\u5b9a\u4e49\uff0c\u53ea\u9700\u91cd\u65b0\u8fd0\u884c\u6b64\u6b65\u9aa4\u5373\u53ef\u3002\u65e0\u9700\u7f16\u8f91\u57fa\u4e8e\u8be5\u7279\u5b9a\u53d7\u4f53\u5b9a\u4e49\u6784\u5efa\u7684\u5176\u4f59\u6d41\u7a0b\u3002</li> </ol>"},{"location":"zh/concepts/basics/aggregation/#agg_repertoires","title":"<code>agg_repertoires()</code>: \u5c06\u53d7\u4f53\u5206\u7ec4\u6210\u6709\u610f\u4e49\u7684\u96c6\u5408","text":"<p>\u4f7f\u7528 <code>immundata::agg_repertoires()</code> \u6765\u58f0\u660e\u5e94\u5982\u4f55\u628a\u53d7\u4f53\u5206\u7ec4\u6210\u7528\u4e8e\u5206\u6790\u7684\u53d7\u4f53\u5e93\uff08repertoires\uff09\u3002</p> <ul> <li>\u7ec4\u4f8b\uff1a\u6765\u81ea\u67d0\u4e00\u6b21\u6d3b\u68c0\u7684\u6240\u6709\u53d7\u4f53\u3001\u6cbb\u7597\u5e94\u7b54\u8005\u7684\u6240\u6709\u53d7\u4f53\u3001\u67d0\u5355\u7ec6\u80de\u7c07\u4e2d\u7684\u53d7\u4f53\uff0c\u6216\u4efb\u610f\u5143\u6570\u636e\u5217\u7684\u7ec4\u5408\u3002</li> <li>\u7ed3\u679c\u662f\u5728\u7269\u7406\u8868 <code>idata$repertoires</code> \u4e2d\u5f97\u5230\u57fa\u672c\u8ba1\u6570\uff08\u94fe\u3001\u6761\u5f62\u7801\u3001\u552f\u4e00\u53d7\u4f53\uff09\u3002\u6bcf\u4e2a\u53d7\u4f53\u5e93\u90fd\u4fdd\u7559\u4e0e\u5176\u6240\u542b\u53d7\u4f53\u7684\u76f4\u63a5\u94fe\u63a5\u3002\u56e0\u6b64\uff0c\u540c\u6837\uff0c\u5e95\u5c42\u6570\u636e\u5e76\u672a\u6539\u53d8\u2014\u2014\u53ea\u662f\u5176\u4e0a\u65b9\u7684\u8f7b\u91cf\u6ce8\u91ca\u3002</li> </ul>"},{"location":"zh/concepts/basics/aggregation/#_1","title":"\u4e3a\u4ec0\u4e48\u8fd9\u79cd\u8bbe\u8ba1\u6709\u5e2e\u52a9","text":"<ul> <li> <p>\u7b80\u5355\u800c\u7cbe\u786e\uff1a \u4f60\u53ef\u4ee5\u8ba1\u7b97\u5ea6\u91cf\uff08\u5982 Jaccard \u76f8\u4f3c\u5ea6\u3001\u591a\u6837\u6027\u7b49\uff09\uff0c\u800c\u4e14\u7cbe\u786e\u7684\u53d7\u4f53\u5b9a\u4e49\uff08\u4f8b\u5982 <code>\"cdr3+v\"</code>\uff09\u4f1a\u548c\u7ed3\u679c\u4e00\u8d77\u4fdd\u5b58\uff0c\u8fd9\u6837\u4f60\u53ef\u4ee5\u6e05\u695a\u8ffd\u6eaf\u5f53\u524d <code>ImmunData</code> \u662f\u5728\u4f55\u79cd\u5b9a\u4e49\u4e0b\u6784\u5efa\u7684\u3002\u8fd9\u51cf\u5c11\u4e86\u4eba\u4e3a\u5931\u8bef\uff0c\u56e0\u4e3a\u6bcf\u6b21\u8ba1\u7b97\u65f6\u4f60\u4e0d\u9700\u8981\u91cd\u590d\u8f93\u5165\u76f8\u540c\u7684\u53d7\u4f53 schema\uff08\u5982 <code>\"cdr3+v\"</code>\uff09\u3002</p> </li> <li> <p>\u5185\u7f6e\u5b8c\u6574\u7684\u6570\u636e\u6cbf\u88ad\uff08data lineage\uff09\uff1a</p> </li> <li> <p>\u6bcf\u4e2a\u53d7\u4f53\u77e5\u9053\u81ea\u5df1\u5305\u542b\u54ea\u4e9b\u94fe\u3002</p> </li> <li>\u6bcf\u4e2a\u53d7\u4f53\u5e93\u77e5\u9053\u81ea\u5df1\u5305\u542b\u54ea\u4e9b\u53d7\u4f53\u3002</li> <li>\u5b8c\u6574\u7684\u201c\u914d\u65b9\u201d\u4fdd\u5b58\u5728 <code>ImmunData</code> \u5bf9\u8c61\u7684\u5143\u6570\u636e\u4e2d\u3002     \u516d\u4e2a\u6708\u4e4b\u540e\u2014\u2014\u6216\u516d\u4f4d\u5ba1\u7a3f\u4eba\u4e4b\u540e\u2014\u2014\u4f60\u90fd\u80fd\u628a\u4efb\u4e00\u6c47\u603b\u7edf\u8ba1\u8ffd\u6eaf\u5230\u4ea7\u751f\u5b83\u7684\u7cbe\u786e\u94fe\uff0c\u5b9e\u73b0\u5b8c\u5168\u53ef\u590d\u73b0\u3001\u65e0\u9690\u6027\u53d8\u6362\u7684\u5206\u6790\u6d41\u7a0b\u3002</li> </ul>"},{"location":"zh/concepts/basics/data_units/","title":"\u5355\u4f4d\uff1a\u94fe\uff08chain\uff09\u2192 \u6761\u5f62\u7801\uff08barcode\uff09\u2192 \u53d7\u4f53\uff08receptor\uff09","text":"<p>\u7b2c\u4e00\u4e2a\u5173\u952e\u6982\u5ff5\u662f\u6570\u636e\u64cd\u4f5c\u7684\u57fa\u672c\u5355\u4f4d\uff0c\u5305\u62ec\uff1a</p> <ul> <li> <p>\u94fe\uff08Chain\uff09\u662f\u4e00\u6761 V(D)J \u5e8f\u5217\u8bb0\u5f55\uff08read/contig/\u5206\u5b50\uff09\uff0c\u4f8b\u5982\u5e26\u6709 V(D)J \u57fa\u56e0\u53ca\u5176\u4ed6\u4fe1\u606f\uff08\u5305\u62ec\u57fa\u56e0\u8868\u8fbe\u4e0e\u514d\u75ab\u539f\u6027\uff09\u7684 TRA\u3001TRB\u3001IGH \u6216 IGL\u3002\u5b83\u662f\u6700\u5c0f\u7684\u6570\u636e\u5355\u4f4d\uff0c\u662f\u4e00\u5207\u7684\u57fa\u77f3\u3002\u6570\u636e\u5bfc\u5165\uff08ingest\uff09\u540e\u4fdd\u6301\u4e0d\u53d8\uff0c\u56e0\u6b64\u4f60\u53ef\u4ee5\u968f\u65f6\u4e0b\u94bb\u5230\u5176\u7cbe\u786e\u7684\u6838\u82f7\u9178/\u6c28\u57fa\u9178\u5e8f\u5217\u53ca\u6ce8\u91ca\u3002</p> </li> <li> <p>\u6761\u5f62\u7801\uff08Barcode\uff09\u662f\u4e00\u4e2a\u7269\u7406\u5bb9\u5668\uff0c\u53ef\u5305\u542b 0\u30011 \u6216\u591a\u6761\u94fe\u3002</p> </li> <li> <p>\u5355\u7ec6\u80de\uff1a\u4e00\u4e2a\u6db2\u6ef4/\u7ec6\u80de\u6761\u5f62\u7801\u3002</p> </li> <li>\u7a7a\u95f4\u8f6c\u5f55\u7ec4\uff1a\u4e00\u4e2a\u70b9\u4f4d\uff08spot\uff09\u6761\u5f62\u7801\uff08\u53ef\u80fd\u6355\u83b7\u6765\u81ea\u591a\u4e2a\u7ec6\u80de\u7684\u8f6c\u5f55\u672c\uff09\u3002</li> <li>\u6279\u91cf\u6d4b\u5e8f\uff08Bulk\uff09\uff1a\u4e0d\u4f7f\u7528\u201cbarcode\u201d\u8fd9\u4e2a\u672f\u8bed\uff0c\u5b9e\u8d28\u4e0a\u628a\u6bcf\u6761\u94fe\u90fd\u89c6\u4f5c\u72ec\u7acb\u7684\u201c\u6761\u5f62\u7801\u201d\u3002</li> </ul> <p>\u5b83\u662f\u201c\u5b58\u653e\u201d\u76f8\u5173\u751f\u7269\u5b66\u6570\u636e\u7684\u751f\u7269\u5b66\u5355\u4f4d\uff0c\u7528\u4e8e\u5bf9\u76f8\u540c\u7684\u94fe\u8fdb\u884c\u805a\u5408\uff0c\u5e76\u7edf\u8ba1\u6765\u81ea\u4e0d\u540c\u6761\u5f62\u7801\u7684\u540c\u4e00\u53d7\u4f53\u7684\u8ba1\u6570\u3002</p> <ul> <li> <p>\u53d7\u4f53\uff08Receptor\uff09\u662f\u94fe\u7684\u903b\u8f91\u5206\u7ec4\uff0c\u4ee3\u8868\u4e00\u4e2a\u7528\u4e8e\u4e0b\u6e38\u5206\u6790\u4e0e\u62a5\u544a\u7684\u751f\u7269\u5b66\u53d7\u4f53\u5b9e\u4f8b\u3002\u6240\u6709\u514d\u75ab\u53d7\u4f53\u5e93\u7edf\u8ba1\u6216\u53d7\u4f53\u8ffd\u8e2a\u90fd\u5728\u53d7\u4f53\u5c42\u9762\u8ba1\u7b97\u3002\u53d7\u4f53\u7531\u7528\u6237\u6307\u5b9a\u7684\u53d7\u4f53\u6a21\u5f0f\uff08schema\uff09\u5b9a\u4e49\uff0c\u5305\u542b\uff1a</p> </li> <li> <p>\u53d7\u4f53\u7279\u5f81\uff1a\u901a\u5e38\u4e3a CDR3 \u6c28\u57fa\u9178\uff08AA\uff09\u5e8f\u5217\uff0c\u53ef\u9009\u5730\u4e0e V \u57fa\u56e0\uff08\u4ee5\u53ca\u9700\u8981\u65f6\u7684 J \u57fa\u56e0\u6216\u957f\u5ea6\uff09\u7ec4\u5408\u3002</p> </li> <li>\u53d7\u4f53\u94fe\uff1a\u4f8b\u5982\u5355\u94fe\u3001\u03b1+\u03b2\uff08TCR\uff09\u3001\u91cd\u94fe+\u8f7b\u94fe\uff08BCR\uff09\uff0c\u6216\u5176\u4ed6\u660e\u786e\u5b9a\u4e49\u7684\u7ec4\u5408\u3002\u5728\u591a\u94fe\u60c5\u5f62\uff08\u5982\u53cc \u03b1\uff09\u4e2d\uff0c\u9700\u8981\u660e\u786e\u4f60\u7684\u914d\u5bf9/\u5408\u5e76\u89c4\u5219\u3002</li> </ul> <p>\u603b\u7ed3\uff1a<code>immundata</code> \u4ee5\u94fe\u5b58\u50a8\u4fe1\u606f\uff0c\u6761\u5f62\u7801\u628a\u591a\u6761\u94fe\u6253\u5305\u5728\u4e00\u8d77\uff0c\u800c\u53d7\u4f53\u662f\u8fdb\u884c\u53d7\u4f53\u5e93\u7edf\u8ba1\u7684\u6700\u5c0f\u5355\u4f4d\u3002</p> \u672f\u8bed \u901a\u4fd7\u89e3\u91ca immundata \u4e2d\u7684\u8868\u793a \u89d2\u8272 Chain\uff08\u94fe\uff09 \u6765\u81ea\u4e00\u6b21 read \u6216 contig \u7684\u5355\u6761 V(D)J \u8f6c\u5f55\u672c\uff08\u5982 TRA \u6216 IGH\uff09\u3002 \u7269\u7406\u8868 <code>idata$annotations</code> \u4e2d\u7684\u4e00\u884c\uff1b\u4fdd\u7559 <code>locus</code>\u3001<code>cdr3</code>\u3001<code>umis</code>/<code>reads</code> \u53ca\u5176\u4ed6\u5173\u952e\u91cd\u6392\u7279\u5f81\u3002 \u539f\u59cb\u6570\u636e\u5355\u4f4d\u2014\u2014\u539f\u5b50\u7ea7\u6784\u4ef6\u3002 Barcode / Cell \u6355\u83b7\u8be5\u94fe\u7684\u6db2\u6ef4\uff0810x\uff09\u3001\u70b9\u4f4d\uff08Visium\uff09\u6216\u5b54\u677f\u5b54\u3002 \u5217 <code>imd_barcode</code>\u3002 \u7269\u7406\u96c6\u5408\u2014\u2014\u5c06\u5171\u4eab\u540c\u4e00\u6355\u83b7\u9694\u95f4\u7684\u94fe\u5206\u7ec4\u3002 Receptor\uff08\u53d7\u4f53\uff09 \u4f60\u8981\u5206\u6790\u7684\u751f\u7269\u5b66\u53d7\u4f53\uff1a\u6765\u81ea\u540c\u4e00\u7ec6\u80de\u7684\u4e00\u6761\u5355\u94fe \u6216 \u4e00\u5bf9\uff08\u03b1\u03b2\u3001\u91cd-\u8f7b\uff09\u94fe\u3002 \u865a\u62df\u8868 <code>idata$receptors</code>\uff1b\u552f\u4e00 ID <code>imd_receptor_id</code>\u3002 \u903b\u8f91\u5355\u4f4d\u2014\u2014AIRR \u7edf\u8ba1\u7684\u6700\u5c0f\u5bf9\u8c61\u3002 Repertoire \u6309\u6837\u672c\u3001\u4f9b\u4f53\u3001\u7ec6\u80de\u7c07\u7b49\u5206\u7ec4\u7684\u4e00\u7ec4\u53d7\u4f53\u3002 \u7269\u7406\u8868 <code>idata$repertoires</code>\uff1b\u552f\u4e00 ID <code>imd_repertoire_id</code>\uff1b\u5305\u542b\u4f60\u9009\u62e9\u7684\u5206\u7ec4\u5217\u3002 \u805a\u5408\u5355\u4f4d\u2014\u2014\u7528\u4e8e\u6bd4\u8f83\u5206\u6790\u7684\u66f4\u9ad8\u5c42\u7ea7\u5206\u7ec4\u3002"},{"location":"zh/concepts/basics/immutability/","title":"\u57fa\u4e8e\u6d41\u6c34\u7ebf\u7684\u6267\u884c\uff1a\u4e0d\u53ef\u53d8\u6027\u4e0e\u7269\u5316\uff08materialization\uff09","text":"<p>\u5728\u524d\u4e24\u4e2a\u6982\u5ff5\u4e2d\u6211\u4eec\u591a\u6b21\u8c08\u5230\u6570\u636e\u53ef\u8ffd\u6eaf\u6027\uff08data lineage\uff09\u3002\u4f46\u53ea\u6709\u5f53\u5de5\u4f5c\u6d41\u7a0b\u4e2d\u7684\u6bcf\u4e00\u6b65\u90fd\u53ef\u88ab\u91cd\u65b0\u6267\u884c\u65f6\uff0c\u6570\u636e\u6cbf\u88ad\u624d\u6709\u610f\u4e49\u2014\u2014\u6362\u53e5\u8bdd\u8bf4\uff0c\u5373\u53ef\u590d\u73b0\u3002\u8981\u8ba9\u7ed3\u679c\u53ef\u590d\u73b0\uff0c\u6bcf\u4e2a\u5206\u6790\u6b65\u9aa4\u90fd\u5fc5\u987b\u80fd\u5728\u5e95\u5c42\u6570\u636e\u53d8\u5316\u65f6\u65e0\u526f\u4f5c\u7528\u5730\u88ab\u8f7b\u677e\u91cd\u8dd1\u3002 \u5728\u7531 <code>immundata</code> \u9a71\u52a8\u7684\u7ba1\u7ebf\u4e2d\uff0c\u4e00\u6b21\u5206\u6790\u662f\u7531\u4e0d\u53ef\u53d8\uff08immutable\uff09\u7684\u8f6c\u6362\u6784\u6210\u7684\u6d41\u6c34\u7ebf\uff1a</p> <ul> <li>\u6bcf\u4e2a\u51fd\u6570\u90fd\u4f1a\u8fd4\u56de\u4e00\u4e2a\u5168\u65b0\u7684 <code>ImmunData</code> \u5bf9\u8c61\u3002</li> <li>\u5e95\u5c42\u6570\u636e\u4e0d\u88ab\u4fee\u6539\u3002\u65b0\u5bf9\u8c61 = \u6570\u636e\u7684\u65b0\u89c6\u56fe\u3002</li> <li>\u8fd9\u4e00\u4e32 <code>ImmunData</code> \u5bf9\u8c61\u8bb0\u5f55\u4e86\u6570\u636e\u5982\u4f55\u4ece\u539f\u59cb\u94fe\uff08chains\uff09\u8d70\u5230\u6700\u7ec8\u6570\u5b57\u3002</li> </ul>"},{"location":"zh/concepts/basics/immutability/#_1","title":"\u9ed8\u8ba4\u843d\u76d8\uff0c\u6309\u9700\u5165\u5185\u5b58","text":"<p>\u4e0d\u53ef\u53d8\u6027\u4e4d\u770b\u5e76\u4e0d\u65b9\u4fbf\uff0c\u4f46\u5b83\u4f7f\u6211\u4eec\u80fd\u591f\u5904\u7406\u5927\u4e8e\u5185\u5b58\uff08larger-than-RAM\uff09\u7684\u514d\u75ab\u53d7\u4f53\u6570\u636e\u96c6\u3002<code>immundata</code> \u4f7f\u7528\u4e86\u591a\u79cd\u806a\u660e\u7684\u6570\u636e\u5de5\u7a0b\u6280\u5de7\uff1a</p> <ul> <li>\u514d\u75ab\u6570\u636e\u8868\u4ee5 Parquet \u6587\u4ef6\u843d\u76d8\uff08\u5217\u5f0f\u538b\u7f29\u683c\u5f0f\uff0c\u52a0\u901f\u6570\u636e\u5206\u6790\uff09\u3002</li> <li>\u53ea\u6709\u5728\u8ba1\u7b97\u9700\u8981\u65f6\u624d\u5c06\u6570\u636e\u7269\u5316\uff08\u5373\u52a0\u8f7d\u5230\u5185\u5b58\uff09\u3002\u4f8b\u5982\u505a\u5b50\u96c6\u6216\u8f93\u51fa\u6700\u7ec8\u6307\u6807\uff08\u5982\u91cd\u53e0\u6307\u6570\uff09\u3002</li> <li>\u5bf9\u4e8e\u4e2d\u7b49\u89c4\u6a21\u6570\u636e\uff08\u5982 ~10 GB\uff09\uff0c\u8fd9\u51e0\u4e4e\u662f\u201c\u65e0\u611f\u201d\u7684\uff1a<code>immundata</code> \u4f7f\u7528\u7684\u8f7b\u91cf\u6570\u636e\u5e93 DuckDB \u4f1a\u4ece\u6587\u4ef6\u6d41\u5f0f\u8bfb\u53d6\uff0c\u5e76\u7ed9\u4f60\u4e00\u4e2a\u5e38\u89c4\u7684\u5185\u5b58\u6570\u636e\u6846\u3002</li> <li>\u800c\u5bf9\u5927\u578b\u6570\u636e\uff08\u5982 ~100 GB\uff09\uff0c\u540c\u4e00\u5957\u4ee3\u7801\u4f9d\u7136\u6709\u6548\uff0c\u56e0\u4e3a Parquet \u4e0e\u6570\u636e\u89c6\u56fe\u7684\u7ec4\u5408\u8ba9 DuckDB \u80fd\u9ad8\u6548\u67e5\u8be2\u5e95\u5c42\u6570\u636e\uff0c\u907f\u514d\u628a\u65e0\u5173\u90e8\u5206\u88c5\u5165\u5185\u5b58\u3002</li> </ul> <p>\u6743\u8861\u5f88\u6e05\u695a\uff1a\u8981\u4e48\u50cf\u5178\u578b\u6570\u636e\u6846\u90a3\u6837\u5168\u90e8\u5728\u5185\u5b58\u4e2d\u5de5\u4f5c\uff08\u5185\u5b58\u6210\u4e3a\u74f6\u9888\uff09\uff1b\u8981\u4e48\u6784\u5efa\u4e0d\u53ef\u53d8\u7684\u8f6c\u6362\uff0c\u8ba9 DuckDB \u4f18\u5316\u5904\u7406\u67e5\u8be2\uff0c\u4ece\u800c\u5b9e\u73b0\u5bf9\u8d85\u5185\u5b58\u6570\u636e\u7684\u652f\u6301\u3002</p>"},{"location":"zh/concepts/basics/immutability/#_2","title":"\u201c\u6d41\u6c34\u7ebf\u601d\u7ef4\u201d\u5728\u65e5\u5e38\u4e2d\u7684\u542b\u4e49","text":"<p>\u4ee5\u4e0d\u53ef\u53d8\u6d41\u6c34\u7ebf\u601d\u8003\u610f\u5473\u7740\u4e24\u4ef6\u4e8b\uff1a</p> <ul> <li>\u521b\u5efa\u5feb\u7167\uff08snapshot\uff09\uff1a \u5f53\u9047\u5230\u6602\u8d35\u6b65\u9aa4\u65f6\uff0c\u4f7f\u7528 <code>immundata::write_immundata()</code> \u4fdd\u5b58\u4e00\u4e2a\u4e2d\u95f4\u7684 <code>ImmunData</code> \u5bf9\u8c61\u3002\u8be5\u51fd\u6570\u4f1a\u751f\u6210\u4e00\u4e2a\u65b0\u7684 <code>ImmunData</code>\uff0c\u4f60\u968f\u540e\u5c31\u7528\u8fd9\u4e2a\u65b0\u5bf9\u8c61\uff0c\u83b7\u5f97\u5927\u5e45\u52a0\u901f\u3002\u793a\u4f8b\uff1a\u8ba1\u7b97\u5230\u67d0\u4e9b\u6a21\u5f0f\u6216\u5e8f\u5217\u7684\u7f16\u8f91\u8ddd\u79bb\u3002\u5982\u679c\u5728\u8fd9\u4e00\u6b65\u540e\u521b\u5efa\u5feb\u7167\uff0c\u8fd9\u4e9b\u8ddd\u79bb\u4f1a\u88ab\u843d\u76d8\uff1b\u5982\u679c\u4e0d\u521b\u5efa\uff0c\u4e4b\u540e\u6bcf\u6b21\u5728\u5f53\u524d <code>ImmunData</code> \u4e0a\u505a\u8f6c\u6362\u6216\u8ba1\u7b97\u65f6\uff0c<code>immundata</code> \u90fd\u5f97\u91cd\u65b0\u8ba1\u7b97\u8ddd\u79bb\u2014\u2014\u800c\u4f60\u77e5\u9053\u8ddd\u79bb\u8ba1\u7b97\u6709\u591a\u8017\u65f6\u3002</li> <li>\u9ed8\u8ba4\u5047\u8bbe\u53ef\u91cd\u8dd1\uff1a \u4efb\u4f55\u4eba\u2014\u2014\u540c\u4e8b\uff0c\u6216\u672a\u6765\u7684\u4f60\u5728\u4e00\u53f0\u66f4\u5f3a\u7684\u673a\u5668\u4e0a\u2014\u2014\u90fd\u5e94\u8be5\u80fd\u4ece\u5934\u5230\u5c3e\u8fd0\u884c <code>pipeline.R</code> \u5e76\u5f97\u5230\u5b8c\u5168\u4e00\u81f4\u7684\u7ed3\u679c\u3002</li> </ul>"},{"location":"zh/concepts/basics/immutability/#_3","title":"\u9762\u5411\u5f00\u53d1\u8005\uff1a\u9690\u85cf\u201c\u6c34\u7ba1\u201d\u7ec6\u8282\uff0c\u628a\u6ce8\u610f\u529b\u8fd8\u7ed9\u751f\u7269\u5b66","text":"<p>\u57fa\u4e8e <code>immundata</code> \u7684\u5305\u5e94\u5f53\u66b4\u9732\u7b80\u5355\u800c\u9ad8\u5c42\u7684\u51fd\u6570\uff0c\u6bd4\u5982 <code>compute_diversity()</code> \u6216 <code>plot_overlap()</code>\u3002 \u7528\u6237\u65e0\u9700\u5173\u5fc3 <code>ImmunData</code>\u3001DuckDB \u6216 Parquet\u3002\u7406\u60f3\u60c5\u51b5\u4e0b\uff0c\u4ed6\u4eec\u751a\u81f3\u5bdf\u89c9\u4e0d\u5230\u6709\u4e00\u4e2a\u843d\u76d8\u6570\u636e\u5e93\u7684\u5b58\u5728\u3002</p> <p>\u628a\u6570\u636e\u5de5\u7a0b\u7559\u7ed9\u6570\u636e\u5de5\u7a0b\u5e08\uff08\u548c\u751f\u7269\u4fe1\u606f\u5b66\u5bb6\uff09\u3002\u628a\u6ce8\u610f\u529b\u653e\u5728\u751f\u7269\u5b66\u4e0a\u2014\u2014\u90a3\u5df2\u7ecf\u8db3\u591f\u590d\u6742\u4e86\u3002</p>"},{"location":"zh/concepts/basics/overview/","title":"Overview ZH","text":"<p><code>immundata</code> splits the workflow into two clear phases:</p> <ol> <li> <p>Ingestion \u2013 convert your AIRR files into a special format saved on disk, and then read them to a tidy <code>immundata::ImmunData</code> object  </p> </li> <li> <p>Transformation  \u2013 explore, annotate, filter and compute on that object</p> </li> </ol> <p>Before we go into more details for each of the phase, there are three straightforward yet essential <code>immundata</code> concepts to keep in mind. These concepts set it apart from data-frame-based AIRR libraries. By extension, the concepts affect how you would work with and even think about the data analysis in other packages such as <code>immunarch</code> which use <code>immundata</code> as a backbone for computations.</p>"},{"location":"zh/howto/immunarch_import/","title":"\u5728 R \u4e2d\u5c06 <code>immunarch::repLoad()</code> \u7684\u8f93\u51fa\u8f6c\u6362\u4e3a <code>ImmunData</code>","text":"<p>\u7528\u4e8e\u5c06 immunarch v0.9 \u7684\u53d7\u4f53\u5e93\u8fc1\u79fb\u4e3a <code>immunarch 0.10/1.0</code> \u4e2d\u7684 ImmunData \u6570\u636e\u96c6\u3002</p> <p>\u5de5\u4f5c\u539f\u7406\uff1a</p> <ul> <li>\u63a5\u6536\u4e00\u4e2a <code>immunarch::repLoad()</code> \u5bf9\u8c61\uff08<code>imm</code>\uff09\u3002</li> <li>\u4e3a\u6bcf\u4e2a\u53d7\u4f53\u5e93\u5404\u5199\u51fa\u4e00\u4e2a TSV\uff08\u5e76\u6dfb\u52a0\u6587\u4ef6\u540d\u5217\uff09\u5230 <code>temp_folder</code>\u3002</li> <li>\u7528 <code>read_repertoires()</code> \u5c06\u8fd9\u4e9b TSV \u5bfc\u5165\u4e3a ImmunData\u3002</li> <li>\u5728 <code>output_folder</code> \u4e0b\u4fdd\u5b58 Parquet \u6587\u4ef6\uff1b\u8fd4\u56de\u4e00\u4e2a ImmunData \u5bf9\u8c61\u3002</li> </ul> <p>\u5173\u952e\u53c2\u6570\uff1a</p> <ul> <li><code>imm</code>\uff1a<code>immunarch::repLoad()</code> \u7684\u8f93\u51fa\u3002</li> <li><code>output_folder</code>\uff1a\u5b58\u653e Parquet \u6570\u636e\u7684\u4f4d\u7f6e\uff08\u81ea\u52a8\u521b\u5efa\uff09\u3002</li> <li><code>schema</code>\uff1a\u5b9a\u4e49\u552f\u4e00\u53d7\u4f53\u952e\u7684\u5b57\u7b26\u5411\u91cf   \uff08\u9ed8\u8ba4 <code>c(\"CDR3.aa\", \"V.name\")</code>\uff1b\u4f60\u4e5f\u53ef\u4ee5\u52a0\u5165 <code>\"J.name\"</code>\uff09\u3002</li> <li><code>temp_folder</code>\uff1a\u5199\u5165\u4e2d\u95f4 TSV \u7684\u4f4d\u7f6e\uff08\u9ed8\u8ba4\u4e3a\u4e34\u65f6\u76ee\u5f55\uff09\u3002</li> </ul> R <pre><code>library(immunarch)\n\n# 1\uff09\u52a0\u8f7d immunarch \u5bf9\u8c61\uff08\u8bfb\u53d6\u6240\u6709\u53d7\u4f53\u5e93 + \u53ef\u9009\u5143\u6570\u636e\uff09\nimmdata &lt;- immunarch::repLoad(\"/path/to/your/files\")\n\n# 2\uff09\u8f6c\u6362\u4e3a ImmunData\uff08\u4ee5 Parquet \u4e3a\u540e\u7aef\uff09\uff0c\u5fc5\u8981\u65f6\u81ea\u5b9a\u4e49\u53d7\u4f53\u952e\nidata &lt;- from_immunarch(\n  imm           = immdata,\n  schema        = c(\"CDR3.aa\", \"V.name\"),    \n  output_folder = \"/path/to/immundata_out\"\n)\n\nidata\n</code></pre> <p>\u53ef\u9009\u5730\uff0c\u4f60\u4e5f\u53ef\u4ee5\u5728\u628a\u5bf9\u8c61\u4f20\u7ed9 <code>from_immunarch</code> \u4e4b\u524d\uff0c\u5148\u5728 <code>immdata</code> \u4e2d\u91cd\u547d\u540d\u5217\uff0c\u4f7f\u5176\u66f4\u8d34\u8fd1 AIRR-C \u683c\u5f0f\uff1a</p> R <pre><code>rename_to_airr &lt;- function(df) {\n  map &lt;- c(\n    \"CDR3.aa\"   = \"cdr3_aa\",\n    \"CDR3.nt\"   = \"cdr3_nt\",\n    \"V.name\"    = \"v_call\",\n    \"D.name\"    = \"d_call\",\n    \"J.name\"    = \"j_call\",\n    \"Clones\"    = \"umi_count\",\n    \"Read.count\"= \"duplicate_count\",\n    \"Barcode\"   = \"cell_id\",\n    \"barcode\"   = \"cell_id\",\n    \"Chain\"     = \"locus\",\n    \"Gene\"      = \"locus\",\n    \"Productive\"= \"productive\"\n  )\n\n  present_old &lt;- intersect(names(df), names(map))\n  if (!length(present_old)) return(df)\n\n  new_names &lt;- unname(map[present_old])\n  keep &lt;- !duplicated(new_names)\n  present_old &lt;- present_old[keep]\n  new_names    &lt;- new_names[keep]\n\n  spec &lt;- stats::setNames(rlang::syms(present_old), new_names)\n  dplyr::rename(df, !!!spec)\n}\n\nimmdata$data &lt;- lapply(immdata$data, rename_to_airr)\n</code></pre>"},{"location":"zh/howto/read_airr_bulk/","title":"\u5728 R \u7684 <code>immunarch</code> \u4e2d\u52a0\u8f7d AIRR-C \u683c\u5f0f\u7684\u6279\u91cf\u6d4b\u5e8f\u514d\u75ab\u53d7\u4f53\u5e93\u6570\u636e","text":"<p>\u9002\u7528\u4e8e\u6279\u91cf AIRR Rearrangement TSV\uff08\u6bcf\u884c\u4e00\u4e2a\u91cd\u6392/\u53d7\u4f53\uff09\u3002\u524d\u63d0\uff1a\u5df2\u5b89\u88c5 <code>immunarch</code>\u3002</p> <p>\u5de5\u4f5c\u539f\u7406\uff1a</p> <ul> <li>\u4ece\u6587\u4ef6\u5939\u8bfb\u53d6\u6240\u6709 AIRR-C TSV\uff08\u6279\u91cf\u6a21\u5f0f\uff09\u3002</li> <li>\u5c06 AIRR \u5b57\u6bb5\uff08\u5982 <code>v_call</code>\u3001<code>j_call</code>\u3001<code>junction_aa</code>\uff09\u6620\u5c04\u5230\u53d7\u4f53 schema\u3002</li> <li>\u4f7f\u7528\u63d0\u4f9b\u7684\u8ba1\u6570\u5b57\u6bb5\u8bbe\u7f6e\u53d7\u4f53\u4e30\u5ea6\u3002</li> </ul> <p>\u5173\u952e\u53c2\u6570\uff1a</p> <ul> <li><code>schema</code>\uff1a\u4f60\u9700\u8981\u7684\u7279\u5f81\uff08\u4f8b\u5982 <code>junction_aa</code>\u3001<code>v_call</code>\u3001<code>j_call</code>\uff09</li> <li><code>path</code>\uff1a\u6587\u4ef6\u3001\u901a\u914d\u7b26\uff08glob\uff09\u6216\u5305\u542b\u6587\u4ef6\u7684\u6587\u4ef6\u5939</li> <li><code>count_col</code>\uff1a\u901a\u5e38\u662f <code>umi_count</code> \u6216 <code>duplicate_count</code>\uff08\u82e5\u5217\u540d\u4e0d\u540c\u8bf7\u76f8\u5e94\u8c03\u6574\uff09</li> </ul> R <pre><code>library(immunarch)\n\nschema &lt;- make_receptor_schema(features = c(\"junction_aa\", \"v_call\"))\n# \u5907\u9009\uff1a\nschema &lt;- make_receptor_schema(features = c(\"cdr3_aa\", \"v_call\"))\n\nidata &lt;- read_repertoires(\n  path       = \"/path/to/bulk_airr/*.tsv\",\n  schema     = schema,\n  count_col  = \"umi_count\",\n  preprocess = make_default_preprocessing(\"airr\")\n)\n\n# \u5982\u679c\u4f60\u6709\u5143\u6570\u636e\uff0c\u53ef\u4ee5\u8fd9\u6837\u4f7f\u7528\uff1a\nidata &lt;- read_repertoires(\n  path       = \"/path/to/bulk_airr/*.tsv\",\n  metadata   = your_metadata_table,\n  schema     = schema,\n  count_col  = \"umi_count\",\n  preprocess = make_default_preprocessing(\"airr\")\n)\n\n# \u5982\u679c\u4f60\u5df2\u7ecf\u77e5\u9053\u53d7\u4f53\u5e93\uff08repertoire\uff09schema\uff1a\nidata &lt;- read_repertoires(\n  path              = \"/path/to/bulk_airr/*.tsv\",\n  metadata          = your_metadata_table,\n  schema            = schema,\n  count_col         = \"umi_count\",\n  preprocess        = make_default_preprocessing(\"airr\"),\n  repertoire_schema = c(\"Patient\", \"Cluster\", \"Response\")\n)\n</code></pre>"},{"location":"zh/howto/read_airr_sc/","title":"\u5728 R \u7684 <code>immunarch</code> \u4e2d\u52a0\u8f7d AIRR-C \u683c\u5f0f\u7684\u5355\u7ec6\u80de\u6d4b\u5e8f\u514d\u75ab\u53d7\u4f53\u5e93\u6570\u636e","text":"<p>\u5f53\u4f60\u7684\u5355\u7ec6\u80de\u6570\u636e\u5bfc\u51fa\u4e3a AIRR-C\uff0c\u4e14\u5305\u542b\u7ec6\u80de\u6761\u5f62\u7801\u4e0e <code>locus</code> \u5217\u65f6\u4f7f\u7528\u6b64\u65b9\u6cd5\u3002</p> <p>\u5de5\u4f5c\u539f\u7406\uff1a</p> <ul> <li>\u8bfb\u53d6 AIRR-C TSV\uff08\u6bcf\u884c\u4e00\u4e2a contig\uff09\u3002</li> <li>\u6309\u6761\u5f62\u7801\u5206\u7ec4\uff0c\u5e76\u6309 <code>locus</code> \u914d\u5bf9\uff08\u4f8b\u5982 <code>TRA</code> + <code>TRB</code>\uff09\u3002\u6216\u4ec5\u9009\u62e9\u6307\u5b9a\u7684\u4f4d\u70b9\u3002</li> <li>\u4f7f\u7528 UMI/reads \u5217\u4e3a\u6bcf\u4e2a\u4f4d\u70b9\u9009\u53d6\u6392\u540d\u6700\u9ad8\u7684 contig\uff08top contig\uff09\u3002</li> </ul> <p>\u5173\u952e\u53c2\u6570\uff1a</p> <ul> <li><code>schema</code>\uff1a\u4f60\u9700\u8981\u7684\u7279\u5f81\uff08\u4f8b\u5982 <code>junction_aa</code>\u3001<code>v_call</code>\u3001<code>j_call</code>\uff09</li> <li><code>path</code>\uff1a\u6587\u4ef6\u3001\u901a\u914d\u7b26\uff08glob\uff09\u6216\u5305\u542b\u6587\u4ef6\u7684\u6587\u4ef6\u5939</li> <li><code>barcode_col</code>\uff1a\u5305\u542b\u6761\u5f62\u7801\u7684\u5217\u2014\u2014<code>cell_id</code></li> <li><code>locus_col</code>\uff1a\u5305\u542b\u4f4d\u70b9\u4fe1\u606f\u7684\u5217\u2014\u2014<code>\"locus\"</code></li> <li><code>umi_col</code>\uff1a\u5305\u542b UMI \u4fe1\u606f\u7684\u5217\uff0c\u901a\u5e38\u662f <code>umi_count</code> \u6216 <code>duplicate_count</code></li> </ul> R <pre><code>library(immunarch)\n\n# \u5982\u679c\u4f60\u6709\u4e24\u6761\u94fe\uff0c\u53ef\u4ee5\u53ea\u9009\u62e9\u5176\u4e2d\u4e00\u6761\u5e76\u8fc7\u6ee4\u5176\u4ed6\uff1a\nschema &lt;- make_receptor_schema(features = c(\"junction_aa\", \"v_call\"), chains = c(\"TCRA\"))\n# \u6216\u521b\u5efa\u914d\u5bf9\u94fe\u53d7\u4f53\uff1a\nschema &lt;- make_receptor_schema(features = c(\"junction_aa\", \"v_call\"), chains = c(\"TCRA\", \"TCRB\"))\n\nidata &lt;- read_repertoires(\n  path        = \"/path/to/sc_airr/*.tsv\",\n  schema      = schema,\n  barcode_col = \"cell_id\",\n  locus_col   = \"locus\",\n  umi_col     = \"umi_count\",\n  preprocess  = make_default_preprocessing(\"airr\")\n)\n\n# \u5982\u679c\u4f60\u6709\u5143\u6570\u636e\uff0c\u53ef\u4ee5\u8fd9\u6837\u4f7f\u7528\uff1a\nidata &lt;- read_repertoires(\n  path        = \"/path/to/sc_airr/*.tsv\",\n  schema      = schema,\n  metadata    = your_metadata_table,\n  barcode_col = \"cell_id\",\n  locus_col   = \"locus\",\n  umi_col     = \"umi_count\",\n  preprocess  = make_default_preprocessing(\"airr\")\n)\n\n# \u5982\u679c\u4f60\u5df2\u7ecf\u77e5\u9053\u53d7\u4f53\u5e93\uff08repertoire\uff09schema\uff1a\nidata &lt;- read_repertoires(\n  path              = \"/path/to/sc_airr/*.tsv\",\n  schema            = schema,\n  metadata          = your_metadata_table,\n  barcode_col       = \"cell_id\",\n  locus_col         = \"locus\",\n  umi_col           = \"umi_count\",\n  preprocess        = make_default_preprocessing(\"airr\"),\n  repertoire_schema = c(\"Patient\", \"Cluster\", \"Response\")\n)\n</code></pre>"},{"location":"zh/intro/quick_start/","title":"\u5feb\u901f\u4e0a\u624b\uff08Quick Start\uff09","text":"<p>\u4e94\u5206\u949f\u5bfc\u89c8\uff1a\u52a0\u8f7d <code>immunarch</code>\uff0c\u83b7\u53d6\u793a\u4f8b\u6570\u636e\uff0c\u8fd0\u884c\u6838\u5fc3\u5206\u6790\uff0c\u5e76\u4f7f\u7528\u968f\u5305\u63d0\u4f9b\u7684 <code>immundata</code> \u5de5\u5177\u6444\u53d6 AIRR \u6570\u636e\u3002</p>"},{"location":"zh/intro/quick_start/#1","title":"1) \u52a0\u8f7d\u5de5\u5177\u5305","text":"R <pre><code>library(immunarch)\n</code></pre>"},{"location":"zh/intro/quick_start/#2","title":"2) \u83b7\u53d6\u793a\u4f8b\u6570\u636e\u5e76\u8bbe\u7f6e\u5206\u7ec4","text":"R <pre><code># \u5c0f\u578b\u6f14\u793a\u6570\u636e\u96c6\nidata &lt;- get_test_idata() |&gt; agg_repertoires(\"Therapy\")\n\n# \u6253\u5370\u7cbe\u7b80\u6458\u8981\nidata\n</code></pre>"},{"location":"zh/intro/quick_start/#3-first-look-analyses","title":"3) \u521d\u6b65\u5206\u6790\uff08First-look analyses\uff09","text":"R <pre><code># \u57fa\u56e0\u4f7f\u7528\uff08\u4f8b\u5982 V \u57fa\u56e0\uff09\nairr_stats_genes(idata, gene_col = \"v_call\") |&gt; vis()\n\n# \u516c\u5171\u6027 / \u91cd\u53e0\nairr_public_jaccard(idata) |&gt; vis()\n\n# \u514b\u9686\u6027\uff08\u4e30\u5ea6\u5206\u7bb1\uff09\nairr_clonality_prop(idata)\n\n# \u591a\u6837\u6027\uff08\u5747\u5300\u5ea6\uff09\nairr_diversity_pielou(idata) |&gt; vis()\n</code></pre>"},{"location":"zh/intro/quick_start/#4-seurat","title":"4)\uff08\u53ef\u9009\uff09\u6309\u53d7\u4f53\u6ce8\u91ca\u514b\u9686\u6027\u5e76\u5728 Seurat \u4e2d\u7ed8\u56fe","text":"R <pre><code># \u6dfb\u52a0\u6bcf\u53d7\u4f53\u7684\u514b\u9686\u6027\u6807\u7b7e\nidata &lt;- annotate_clonality_prop(idata)\n\n# \u6309\u6761\u5f62\u7801\u628a\u6807\u7b7e\u62f7\u8d1d\u5230 Seurat \u5bf9\u8c61\u5e76\u7ed9 UMAP \u4e0a\u8272\n#\uff08\u5047\u8bbe\u4f60\u5728\u6d41\u7a0b\u65e9\u524d\u5df2\u521b\u5efa\u4e86 `sdata`\uff09\nsdata &lt;- annotate_seurat(idata, sdata, cols = \"clonal_prop_bin\")\nSeurat::DimPlot(sdata, reduction = \"umap\", group.by = \"clonal_prop_bin\", shuffle = TRUE)\n</code></pre>"},{"location":"zh/intro/quick_start/#5-airr","title":"5)\uff08\u53ef\u9009\uff09\u4f7f\u7528\u968f\u5305\u7684\u6570\u636e\u5c42\u6444\u53d6 AIRR \u6570\u636e","text":"<p><code>immundata</code> \u4e0e <code>immunarch</code> \u4e00\u8d77\u53d1\u5e03\u3002\u4f60\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u5176\u8bfb\u53d6\u51fd\u6570\u4ee5\u7075\u6d3b\u5bfc\u5165\u3002</p> R <pre><code># \u8bfb\u53d6 AIRR TSV\uff08\u793a\u4f8b\uff09\nmd_path &lt;- system.file(\"extdata/tsv\", \"metadata.tsv\", package = \"immundata\")\nfiles &lt;- c(\n    system.file(\"extdata/tsv\", \"sample_0_1k.tsv\", package = \"immundata\"),\n    system.file(\"extdata/tsv\", \"sample_1k_2k.tsv\", package = \"immundata\")\n)\n\nmd &lt;- read_metadata(md_path)\nidata &lt;- read_repertoires(\npath     = files,\nschema   = c(\"cdr3_aa\", \"v_call\"),\nmetadata = md\n)\n\n# \u7ee7\u7eed\u8fdb\u884c immunarch \u5206\u6790\nidata |&gt; agg_repertoires(\"Therapy\") |&gt; airr_clonality_prop()\n</code></pre>"},{"location":"zh/intro/quick_start/#next-steps","title":"\u540e\u7eed\u6b65\u9aa4\uff08Next steps\uff09","text":"<ul> <li>\u67e5\u770b\u6211\u4eec\u7684\u8be6\u7ec6\u6559\u7a0b\u3002</li> </ul>"},{"location":"zh/tutorials/single_cell/#load-airr-data","title":"Load AIRR data","text":"<p>First, we need to load sample metadata. The metadata file is a tab-separated table, where each row represents a sample (or file), and columns contain sample-level features such as <code>\"Tissue\"</code>, <code>\"Donor\"</code>, or <code>\"ImmunotherapyResponse\"</code>.</p> R <pre><code>md_file &lt;- system.file(\"extdata/single_cell\", \"metadata.tsv\", package = \"immundata\")\nmd_file\n</code></pre> <pre><code>[1] \"/home/runner/work/_temp/Library/immundata/extdata/single_cell/metadata.tsv\"\n</code></pre> <pre><code>md_table &lt;- read_metadata(md_file)\n</code></pre> <pre><code>Rows: 3 Columns: 3\n\u2500\u2500 Column specification \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nDelimiter: \"\\t\"\nchr (3): File, Tissue, Prefix\n\n\u2139 Use `spec()` to retrieve the full column specification for this data.\n\u2139 Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\u2139 Found 3/3 repertoire files from the metadata on the disk\n\n\u2714 Metadata parsed successfully\n</code></pre> <pre><code>md_table\n</code></pre> <pre><code># A tibble: 3 \u00d7 4\n  File                                                    Tissue Prefix filename\n  &lt;chr&gt;                                                   &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;   \n1 /home/runner/work/_temp/Library/immundata/extdata/sing\u2026 Blood  LB6_   /home/r\u2026\n2 /home/runner/work/_temp/Library/immundata/extdata/sing\u2026 Normal LN6_   /home/r\u2026\n3 /home/runner/work/_temp/Library/immundata/extdata/sing\u2026 Tumor  LT6_   /home/r\u2026\n</code></pre> <p>The <code>\"Tissue\"</code> column defines which biological compartment (tumour, blood, or NAT) each sample comes from. We'll use it to split data into repertoires. Later in this tutorial, you'll see how to dynamically split data by other annotations, such as cell clusters from scRNA-seq.</p> <p>Next, get the file paths to the V(D)J data packaged with <code>immundata</code>:</p> R <pre><code>inp_files &lt;- paste0(system.file(\"extdata/single_cell\", \"\", package = \"immundata\"), \"/*.csv.gz\")\ninp_files\n</code></pre> <pre><code>[1] \"/home/runner/work/_temp/Library/immundata/extdata/single_cell//*.csv.gz\"\n</code></pre> <p>What is a receptor in <code>immundata</code>? A receptor is the central unit of data analysis in <code>immundata</code>. It is defined by:</p> <ul> <li>The features used for grouping (e.g., <code>cdr3</code>, <code>v_call</code>, <code>j_call</code>)</li> <li>The chains involved (e.g., <code>TRB</code> for TCR beta, or paired     <code>TRA</code>+<code>TRB</code>)</li> </ul> <p>Defining a receptor schema lets you flexibly group TCR/BCR sequences for downstream analysis and compute statistics on them.</p> <p>Here's how to define a basic single-chain receptor schema: TRB chains, grouped by both <code>cdr3</code> and <code>v_call</code> (amino acid sequence and V gene).</p> R <pre><code>schema &lt;- make_receptor_schema(features = c(\"cdr3\", \"v_call\"), chains = c(\"TRB\"))\nschema\n</code></pre> <pre><code>$features\n[1] \"cdr3\"   \"v_call\"\n\n$chains\n[1] \"TRB\"\n</code></pre> <p>If you want to use other receptor definitions, you can create and pass custom schemas to <code>read_repertoires()</code>. Below are a few examples:</p> R <pre><code># Paired-chain\nschema &lt;- make_receptor_schema(features = c(\"cdr3\", \"v_call\"), chains = c(\"TRA\", \"TRB\"))\nschema\n</code></pre> <pre><code>$features\n[1] \"cdr3\"   \"v_call\"\n\n$chains\n[1] \"TRA\" \"TRB\"\n</code></pre> <pre><code># Single-chain with \"cdr3\" only\nschema &lt;- make_receptor_schema(features = c(\"cdr3\"), chains = c(\"TRA\"))\nschema\n</code></pre> <pre><code>$features\n[1] \"cdr3\"\n\n$chains\n[1] \"TRA\"\n</code></pre> <pre><code># The most strict receptor definition\nschema &lt;- make_receptor_schema(features = c(\"cdr3\", \"v_call\", \"j_call\"), chains = c(\"TRA\", \"TRB\"))\nschema\n</code></pre> <pre><code>$features\n[1] \"cdr3\"   \"v_call\" \"j_call\"\n\n$chains\n[1] \"TRA\" \"TRB\"\n</code></pre> <p>The main entry point for loading AIRR-seq data into the <code>immunarch 1.0</code> framework is the <code>read_repertoires()</code> function from <code>immundata</code>. This function handles everything from reading raw files, to preprocessing and aggregation, to joining metadata and saving an efficient on-disk ImmunData object for reproducible analysis.</p> <p>Below, we describe the key parameters you'll want to understand:</p> <ul> <li><code>path</code> --- vector of input file paths, e.g., to AIRR TSV, 10X     CSV, or Parquet files. (You can use <code>Sys.glob()</code> to collect files.)</li> <li><code>schema</code> --- defines how receptors are grouped; typically     created with <code>make_receptor_schema()</code>.</li> <li><code>metadata</code> --- optional data frame with sample-level metadata,     read by <code>read_metadata()</code>.</li> <li><code>barcode_col</code> --- name of the column containing cell barcodes     (e.g., <code>\"barcode\"</code> for 10x single-cell data); this triggers     single-cell logic.</li> <li><code>locus_col</code> --- name of the column specifying the chain (e.g.,     <code>\"locus\"</code> for TRA/TRB distinction).</li> <li><code>umi_col</code> --- column for UMI counts (e.g., <code>\"umis\"</code>); used to     select dominant chains per barcode.</li> <li><code>preprocess</code> --- list of preprocessing steps to apply before     aggregation. The preset <code>make_default_preprocessing(\"10x\")</code> works     for standard 10x data.</li> <li><code>repertoire_schema</code> --- columns in metadata (or annotation) used     to define repertoires (e.g., <code>\"Tissue\"</code> to split by compartment).</li> </ul> <p>Here's how to use it on the packaged single-cell demo dataset:</p> R <pre><code>schema &lt;- make_receptor_schema(features = c(\"cdr3\", \"v_call\"), chains = c(\"TRB\"))\n\nidata &lt;- read_repertoires(path = inp_files, \n                          schema = schema, \n                          metadata = md_table, \n                          barcode_col = \"barcode\", \n                          locus_col = \"locus\",  # Mind that we use `locus` here because of column renaming\n                          umi_col = \"umis\",\n                          preprocess = make_default_preprocessing(\"10x\"), \n                          repertoire_schema = \"Tissue\")\n</code></pre> <pre><code>\n</code></pre> <pre><code>\u2500\u2500 Reading repertoire data \n</code></pre> <pre><code>  1. /home/runner/work/_temp/Library/immundata/extdata/single_cell/lb6.csv.gz\n</code></pre> <pre><code>  2. /home/runner/work/_temp/Library/immundata/extdata/single_cell/ln6.csv.gz\n</code></pre> <pre><code>  3. /home/runner/work/_temp/Library/immundata/extdata/single_cell/lt6.csv.gz\n</code></pre> <pre><code>\u2139 Checking if all files are of the same type\n</code></pre> <pre><code>\u2714 All files have the same extension\n</code></pre> <pre><code>\n</code></pre> <pre><code>\u2500\u2500 Renaming the columns and schemas \n</code></pre> <pre><code>\u2714 Introduced new renamed columns: locus, v_call, d_call, and j_call\n</code></pre> <pre><code>\u2714 Renaming is finished\n</code></pre> <pre><code>\n</code></pre> <pre><code>\u2500\u2500 Preprocessing the data \n</code></pre> <pre><code>  1. exclude_columns\n</code></pre> <pre><code>  2. filter_nonproductive\n</code></pre> <pre><code>\u2714 Preprocessing plan is ready\n</code></pre> <pre><code>\n</code></pre> <pre><code>\u2500\u2500 Aggregating the data to receptors \n</code></pre> <pre><code>\u2139 Found target locus: TRB. The dataset will be pre-filtered to leave chains for this locus only\n</code></pre> <pre><code>\u2139 Processing data as single-cell sequencing immune repertoires - no counts, with barcodes, chain pairing is possible\n</code></pre> <pre><code>\u2714 Execution plan for receptor data aggregation and annotation is ready\n</code></pre> <pre><code>\n</code></pre> <pre><code>\u2500\u2500 Joining the metadata table with the dataset using 'filename' column \n</code></pre> <pre><code>\u2714 Joining plan is ready\n</code></pre> <pre><code>\n</code></pre> <pre><code>\u2500\u2500 Postprocessing the data \n</code></pre> <pre><code>  1. prefix_barcodes\n</code></pre> <pre><code>\u2714 Postprocessing plan is ready\n</code></pre> <pre><code>\n</code></pre> <pre><code>\u2500\u2500 Saving the newly created ImmunData to disk \n</code></pre> <pre><code>\u2139 Writing the receptor annotation data to [/home/runner/work/_temp/Library/immundata/extdata/single_cell/immundata-lb6.csv/annotations.parquet]\n</code></pre> <pre><code>\u2139 Writing the metadata to [/home/runner/work/_temp/Library/immundata/extdata/single_cell/immundata-lb6.csv/metadata.json]\n</code></pre> <pre><code>\u2714 ImmunData files saved to [/home/runner/work/_temp/Library/immundata/extdata/single_cell/immundata-lb6.csv]\n</code></pre> <pre><code>\u2139 Reading ImmunData files from ['/home/runner/work/_temp/Library/immundata/extdata/single_cell/immundata-lb6.csv']\n</code></pre> <pre><code>\u2714 Loaded ImmunData with the receptor schema: [c(\"cdr3\", \"v_call\") and TRB]\n</code></pre> <pre><code>\u2139 Reading ImmunData files from ['/home/runner/work/_temp/Library/immundata/extdata/single_cell/immundata-lb6.csv']\n</code></pre> <pre><code>\n</code></pre> <pre><code>\u2500\u2500 Aggregating repertoires... \n</code></pre> <pre><code>\u2714 Aggregation is finished\n</code></pre> <pre><code>\n</code></pre> <pre><code>\u2500\u2500 Summary \n</code></pre> <pre><code>\u2139 Time elapsed: 5.72 secs\n</code></pre> <pre><code>\u2714 Loaded ImmunData with the receptor schema: [c(\"cdr3\", \"v_call\") and TRB]\n</code></pre> <pre><code>\u2714 Loaded ImmunData with the repertoire schema: [Tissue]\n</code></pre> <pre><code>\u2714 Loaded ImmunData with [18714] chains\n</code></pre> <pre><code>NULL\n</code></pre> <pre><code>NULL\n</code></pre> <p>The result, <code>idata</code>, is an ImmunData object --- a columnar, on-disk structure similar in spirit to Seurat or AnnData, but specifically optimized for immune repertoire analysis. You can query, annotate, or regroup it on the fly, and it remains memory efficient and fully reproducible.</p>"},{"location":"zh/tutorials/single_cell/#load-scrnaseq-data","title":"Load scRNAseq data","text":"<p>If you're working with single-cell transcriptomics, you'll usually want to bring in cluster annotations or cell type labels. This can be done with a simple TSV table, or directly from a Seurat/AnnData object.</p> R <pre><code>cells_file &lt;- system.file(\"extdata/single_cell\", \"cells.tsv.gz\", package = \"immundata\")\ncells_file\n</code></pre> <pre><code>[1] \"/home/runner/work/_temp/Library/immundata/extdata/single_cell/cells.tsv.gz\"\n</code></pre> <pre><code>cells &lt;- readr::read_tsv(cells_file)\n</code></pre> <pre><code>Rows: 15174 Columns: 6\n\u2500\u2500 Column specification \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nDelimiter: \"\\t\"\nchr (4): barcode, ident, sample, source\ndbl (2): UMAP_1, UMAP_2\n\n\u2139 Use `spec()` to retrieve the full column specification for this data.\n\u2139 Specify the column types or set `show_col_types = FALSE` to quiet this message.\n</code></pre> <pre><code>head(cells)\n</code></pre> <pre><code># A tibble: 6 \u00d7 6\n  barcode                ident     sample source UMAP_1  UMAP_2\n  &lt;chr&gt;                  &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n1 LT6_AAACCTGAGCGTTCCG-1 8.4-Chrom LT6    Tumor   0.870  0.0175\n2 LT6_AAACCTGCATCGTCGG-1 4.4-FOS   LT6    Tumor  -3.75  -0.445 \n3 LT6_AAACCTGGTACGAAAT-1 4.6a-Treg LT6    Tumor  -2.28  -4.70  \n4 LT6_AAACCTGGTAGAGTGC-1 4.1-Trm   LT6    Tumor  -3.31  -1.28  \n5 LT6_AAACCTGGTTACGTCA-1 4.3-TCF7  LT6    Tumor  -6.93  -0.653 \n6 LT6_AAACCTGTCCGTTGCT-1 4.6b-Treg LT6    Tumor  -0.644 -5.03  \n</code></pre> <p>To visualize gene expression and link it with immune repertoires, load the expression matrix into a Seurat object. Here, we use a cached RDS to speed up the tutorial:</p> R <pre><code>url &lt;- \"https://zenodo.org/records/15604205/files/l6data.rds?download=1\"\ndest &lt;- BiocFileCache::bfcrpath(BiocFileCache::BiocFileCache(ask = FALSE), url)\n\nmat &lt;- readr::read_rds(dest)\n\nsdata &lt;- CreateSeuratObject(counts = mat)\n</code></pre> <pre><code>Warning: Data is of class matrix. Coercing to dgCMatrix.\n</code></pre> <pre><code>embeddings &lt;- as.matrix(cells[c(\"UMAP_1\", \"UMAP_2\")])\nrownames(embeddings) &lt;- cells$barcode\n\numap_dr &lt;- CreateDimReducObject(embeddings = embeddings, key = \"UMAP_\", assay = DefaultAssay(sdata))\n\nsdata[[\"umap\"]] &lt;- umap_dr\n\nIdents(sdata) &lt;- setNames(cells$ident, cells$barcode)\n\nDimPlot(sdata, reduction = \"umap\", order = sort(unique(cells$ident), decreasing = TRUE), label = TRUE, alpha = .5)\n</code></pre> <pre><code>Warning: `aes_string()` was deprecated in ggplot2 3.0.0.\n\u2139 Please use tidy evaluation idioms with `aes()`.\n\u2139 See also `vignette(\"ggplot2-in-packages\")` for more information.\n\u2139 The deprecated feature was likely used in the Seurat package.\n  Please report the issue at &lt;https://github.com/satijalab/seurat/issues&gt;.\n</code></pre> <p></p> <p>Tip: The <code>cells</code> object here includes precomputed UMAP coordinates to save time. In a real-world workflow, you would extract cluster labels and embeddings from your processed Seurat/AnnData object and merge them with your immune receptor data for downstream analysis.</p>"},{"location":"zh/tutorials/single_cell/#1a-number-of-receptors-and-barcodes-for-samples","title":"1a. Number of receptors and barcodes for samples","text":"<p>Let's start by quantifying two basic properties:</p> <ul> <li> <p>Number of unique barcodes per sample (reflects cell yield /     diversity)</p> </li> <li> <p>Number of unique receptors per sample (reflects immune diversity and     capture)</p> </li> </ul> <p>These metrics are often used as a first-line QC and as a way to detect outliers or sample-specific technical effects.</p> R <pre><code>idata_stats &lt;- airr_stats_chains(idata)\n\nidata_stats\n</code></pre> <pre><code># A tibble: 3 \u00d7 6\n  imd_repertoire_id n_barcodes n_receptors locus n_chains Tissue\n*             &lt;int&gt;      &lt;dbl&gt;       &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;chr&gt; \n1                 2       6797        2950 TRB       6797 Normal\n2                 3       7832        3962 TRB       7832 Tumor \n3                 1       4085        3976 TRB       4085 Blood \n</code></pre> <pre><code>p1 &lt;- idata_stats |&gt; vis(xval = \"Tissue\", yval = \"n_receptors\", fill = \"Tissue\", title = \"No. barcodes per sample\")\np2 &lt;- idata_stats |&gt; vis(xval = \"Tissue\", yval = \"n_receptors\", fill = \"Tissue\", title = \"No. receptors per sample\")\np1 + p2\n</code></pre> <p></p> <ul> <li> <p>Possible interpretation of results:</p> <ul> <li> <p>Large differences in barcode count may indicate sample quality     or biological differences (e.g., tumour-infiltrating T cell     abundance, malignant cells).</p> </li> <li> <p>Receptor count per sample gives a sense of diversity captured     and can flag technical dropouts or high expansion.</p> </li> </ul> </li> </ul>"}]}