---
title: "Comprehensive analysis of single-cell immune repertoire data using `immunarch` and `immundata`"
author: "Vadim I. Nazarov"
date: "`r Sys.Date()`"
# format: gfm
# engine: knitr
format: 
  html:
    code-overflow: wrap
    code-block-bg: true
    code-block-border-left: "#31BAE9"
    highlight-style: github
    code-line-numbers: false
    code-copy: true
    toc: true
    number-sections: true
    # theme: none
    # minimal: true
vignette: >
  %\VignetteIndexEntry{Comprehensive analysis of single-cell immune repertoire data}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---

## Introduction

This vignette is a practical, end‑to‑end guide to analyzing single‑chain and paired‑chain Adaptive Immune Receptor Repertoire (AIRR) data derived from single‑cell assays (scRNA‑seq with VDJ; also referred to as scVDJ‑seq / scTCR‑seq / scBCR‑seq). It starts from the basics and builds up to more advanced analyses, so it can serve both as a first stop for newcomers and as a focused introduction for experienced readers who want to learn **`immunarch`** and **`immundata`** specifically.

### What you’ll learn

* Load single‑cell V(D)J data and metadata into `immunarch`/`immundata`.
* Define clonotypes (AA vs NT), set chain‑pairing rules, and perform essential QC.
* Explore repertoire features: expansion, gene usage, CDR3 properties, and diversity.
* Quantify overlap/similarity between samples and conditions.
* Link clonotypes to single‑cell transcriptomic clusters for downstream interpretation.

### Dataset used in this tutorial

We will work with data for **patient 6** from the study **“Peripheral T cell expansion predicts tumour infiltration and clinical response”** (Wu *et al.*; *Nature* 579:274–278, 2020). The dataset includes three compartments per patient: **tumour**, **peripheral blood**, and **normal adjacent tissue (NAT)**. We will demonstrate a typical single‑cell AIRR workflow across these three samples.

**Study in one sentence.** Deep single‑cell RNA/TCR profiling across tumour, NAT, and blood shows **clonotypic expansion of effector‑like T cells** in and around tumours; **patients with stronger peripheral expansion signatures tend to respond better to anti‑PD‑(L)1 therapy**, and expanded intratumoural clonotypes are often detectable in blood, enabling convenient monitoring.

**References & data access:**

* Wu TD, Madireddi S, de Almeida PE, *et al.* *Nature* (2020). “Peripheral T cell expansion predicts tumour infiltration and clinical response.”
* GEO series: **GSE139555** (single‑cell RNA/TCR; pretreatment samples from 14 patients; tumour/NAT/blood).

### Helpful links

* Source code and issue tracker: [`immunarch`](https://github.com/immunomind/immunarch) · [`immundata`](https://github.com/immunomind/immundata)
* Interactive assistant: **AIRR‑GPT** — a GPT Store model preloaded with `immunarch` and `immundata` docs to help you as you go: [https://chatgpt.com/g/g-67fe54e302348191814e4ef2efb3bad5-airr-gpt](https://chatgpt.com/g/g-67fe54e302348191814e4ef2efb3bad5-airr-gpt)

---

## Setup

=== "R"

    ### Pre-requisites
    
    * **R** ≥ 4.2 (4.3+ recommended)
    * Internet access to install packages and download data from GEO
    * \~2–4 GB RAM free for the small demonstration subset used here
    
    You can install the required packages with **pak** (recommended for reproducibility and fast binary installs) or with base installers.
    
=== "Python"

    ### Test
    
    test, don't mind me...

### Using `pak`

=== "R"

    ```{r}
    #| eval: false
    install.packages("pak", repos = sprintf("https://r-lib.github.io/p/pak/stable/%s/%s/%s", .Platform$pkgType, R.Version()$os, R.Version()$arch))
    
    pak::pkg_install("immunomind/immunarch")
    pak::pkg_install("Seurat")
    pak::pkg_install("BiocFileCache")
    pak::pkg_install("ggthemes")
    pak::pkg_install("ggsci")
    ```

### Using CRAN

=== "R"

    ```{r}
    #| eval: false
    install.packages(c("immunarch", "Seurat", "BiocFileCache", "ggthemes", "ggsci"))
    ```

> *Tip:* If you prefer fully reproducible environments, consider using `renv::init()` to snapshot package versions.

=== "R"

    ```{r}
    #| eval: !expr requireNamespace("Seurat", quietly = TRUE)
    #| echo: false
    #| message: false
    #| warning: false
    pak::pkg_install("Seurat")
    ```

=== "R"

    ```{r}
    #| eval: !expr requireNamespace("BiocFileCache", quietly = TRUE)
    #| echo: false
    #| message: false
    #| warning: false
    pak::pkg_install("BiocFileCache")
    ```

=== "R"

    ```{r}
    #| eval: !expr requireNamespace("ggthemes", quietly = TRUE)
    #| echo: false
    #| message: false
    #| warning: false
    pak::pkg_install("ggthemes")
    ```

=== "R"

    ```{r}
    #| eval: !expr requireNamespace("ggsci", quietly = TRUE)
    #| echo: false
    #| message: false
    #| warning: false
    pak::pkg_install("ggsci")
    ```


### Load necessary packages and setup

=== "R"

    ```{r}
    #| label: load-immunarch
    #| eval: true
    #| echo: true
    #| message: false
    #| warning: false
    
    # Silence noisy startup messages while loading
    suppressPackageStartupMessages({
      library(immunarch)
      library(Seurat)
      library(BiocFileCache)
      library(ggplot2)
      library(ggthemes)
      library(ggsci)
    })
    
    theme_set(ggthemes::theme_few())
    
    # Keep a snapshot of versions for reproducibility (printed at the end as well)
    pkg_versions <- list(
      immunarch = as.character(utils::packageVersion("immunarch")),
      Seurat    = as.character(utils::packageVersion("Seurat"))
    )
    
    pkg_versions
    ```

---

## Typical workflow: from files to analysis

Analyzing single-cell AIRR data with `immunarch 1.0` powered by `immundata` follows a clear, reproducible workflow that separates **data ingestion** from **downstream transformation** and annotation. This design enables you to process and reuse large datasets efficiently without manual reloading or reprocessing.

The general workflow is:

1. **Ingestion phase**

   * Read metadata (optional but recommended)
   * Load AIRR-seq files and preprocess as needed
   * Define receptors using a schema (single or paired chains, custom features)
   * Aggregate and persist the dataset as an immutable on-disk `ImmunData` object

2. **Transformation phase**

   * Annotate `ImmunData` with external information (e.g., scRNA-seq clusters)
   * Regroup repertoires on the fly (e.g., by tissue, donor, or cell state)
   * Filter, mutate, and compute statistics without copying or reloading data
   * Visualize results, save plots, or export annotations back to Seurat/AnnData

This separation of phases lets you:

* Ingest and **persist raw AIRR-seq data** once, then reload instantly for any analysis
* **Dynamically regroup** or annotate data without touching the original files
* Build fully reproducible pipelines, as each step leaves previous data untouched

You can read more about the phases in [Concepts](https://immunomind.github.io/docs/concepts/basics/).

### Note on materialization

The `ImmunData` object in `immundata` is designed to handle large, out-of-memory datasets efficiently. Instead of loading everything into RAM, it tracks computations and only runs them when the results are actually needed—such as for plotting or summarizing data. This is called **lazy evaluation**.

**Materialization** means executing all pending computations and bringing the results into memory as a concrete table or data frame. This approach is powerful for working with large datasets, but can be unfamiliar if you’re used to working entirely in-memory.

If you see an error like:

```
Error: Materialization is disabled, use collect() or as_tibble() to materialize.
```

…it means your data hasn’t been materialized yet (i.e., the computation hasn’t run and the results aren’t present in R memory).

* For **small results** (e.g., summary stats, small tables), simply call `collect()` or `as_tibble()` at the end of your pipeline to materialize the data:

  ```r
  result <- immunarch_function(idata) |> collect()
  ```
* For **large datasets** (e.g., a fully filtered `ImmunData` object), avoid materializing unless you’re sure you need all data in memory—this could use significant RAM and slow down your workflow.

**Tip:**
Use materialization for final summaries, plots, or tables, but keep your core ImmunData object on disk and in its lazy, efficient format for most analyses.

You can read more about the materialization in [Concepts](https://immunomind.github.io/docs/concepts/immutability/).

---

## Working with data

### Load AIRR data

First, we need to load sample metadata. The metadata file is a tab-separated table, where each row represents a sample (or file), and columns contain sample-level features such as `"Tissue"`, `"Donor"`, or `"ImmunotherapyResponse"`.

=== "R"

    ```{r}
    #| label: load-dataset-metadata
    
    md_file <- system.file("extdata/single_cell", "metadata.tsv", package = "immundata")
    md_file
    
    md_table <- read_metadata(md_file)
    md_table
    ```

The `"Tissue"` column defines which biological compartment (tumour, blood, or NAT) each sample comes from. We’ll use it to split data into **repertoires**. Later in this tutorial, you’ll see how to dynamically split data by other annotations, such as cell clusters from scRNA-seq.

Next, get the file paths to the V(D)J data packaged with `immundata`:

=== "R"

    ```{r}
    #| label: load-dataset-files
    #| 
    inp_files <- paste0(system.file("extdata/single_cell", "", package = "immundata"), "/*.csv.gz")
    inp_files
    ```

**What is a receptor in `immundata`?** A **receptor** is the central unit of data analysis in `immundata`. It is defined by:
* The **features** used for grouping (e.g., `cdr3`, `v_call`, `j_call`)
* The **chains** involved (e.g., `TRB` for TCR beta, or paired `TRA`+`TRB`)

Defining a receptor schema lets you flexibly group TCR/BCR sequences for downstream analysis and compute statistics on them.

Here’s how to define a basic single-chain receptor schema: TRB chains, grouped by both `cdr3` and `v_call` (amino acid sequence and V gene).

=== "R"

    ```{r}
    #| label: load-dataset-schema
    #| eval: true
    
    schema <- make_receptor_schema(features = c("cdr3", "v_call"), chains = c("TRB"))
    schema
    ```

If you want to use other receptor definitions, you can create and pass custom schemas to `read_repertoires()`. Below are a few examples:

=== "R"

    ```{r}
    #| label: load-dataset-schema-examples
    #| eval: true
    
    # Paired-chain
    schema <- make_receptor_schema(features = c("cdr3", "v_call"), chains = c("TRA", "TRB"))
    schema
    
    # Single-chain with "cdr3" only
    schema <- make_receptor_schema(features = c("cdr3"), chains = c("TRA"))
    schema
    
    # The most strict receptor definition
    schema <- make_receptor_schema(features = c("cdr3", "v_call", "j_call"), chains = c("TRA", "TRB"))
    schema
    ```

The main entry point for loading AIRR-seq data into the `immunarch 1.0` framework is the `read_repertoires()` function from `immundata`. This function handles everything from reading raw files, to preprocessing and aggregation, to joining metadata and saving an efficient on-disk ImmunData object for reproducible analysis.

Below, we describe the key parameters you’ll want to understand:

* **`path`** — vector of input file paths, e.g., to AIRR TSV, 10X CSV, or Parquet files. (You can use `Sys.glob()` to collect files.)
* **`schema`** — defines how receptors are grouped; typically created with `make_receptor_schema()`.
* **`metadata`** — optional data frame with sample-level metadata, read by `read_metadata()`.
* **`barcode_col`** — name of the column containing cell barcodes (e.g., `"barcode"` for 10x single-cell data); this triggers single-cell logic.
* **`locus_col`** — name of the column specifying the chain (e.g., `"locus"` for TRA/TRB distinction).
* **`umi_col`** — column for UMI counts (e.g., `"umis"`); used to select dominant chains per barcode.
* **`preprocess`** — list of preprocessing steps to apply before aggregation. The preset `make_default_preprocessing("10x")` works for standard 10x data.
* **`repertoire_schema`** — columns in metadata (or annotation) used to define repertoires (e.g., `"Tissue"` to split by compartment).

Here’s how to use it on the packaged single-cell demo dataset:

=== "R"

    ```{r}
    #| label: load-dataset-airr
    #| eval: true
    #| cache: false
    
    schema <- make_receptor_schema(features = c("cdr3", "v_call"), chains = c("TRB"))
    
    idata <- read_repertoires(path = inp_files, schema = schema, metadata = md_table, barcode_col = "barcode", locus_col = "locus", umi_col = "umis", preprocess = make_default_preprocessing("10x"), repertoire_schema = "Tissue")
    
    NULL
    ```

The result, `idata`, is an **ImmunData** object—a columnar, on-disk structure similar in spirit to Seurat or AnnData, but specifically optimized for immune repertoire analysis. You can query, annotate, or regroup it on the fly, and it remains memory efficient and fully reproducible.

### Load scRNAseq data

If you’re working with single-cell transcriptomics, you’ll usually want to bring in cluster annotations or cell type labels. This can be done with a simple TSV table, or directly from a Seurat/AnnData object.

=== "R"

    ```{r}
    #| label: load-dataset-cells
    #| eval: true
    
    cells_file <- system.file("extdata/single_cell", "cells.tsv.gz", package = "immundata")
    cells_file
    
    cells <- readr::read_tsv(cells_file)
    cells
    ```

To visualize gene expression and link it with immune repertoires, load the expression matrix into a Seurat object. Here, we use a cached RDS to speed up the tutorial:

=== "R"

    ```{r}
    #| label: load-dataset-seurat
    #| eval: true
    
    url <- "https://zenodo.org/records/15604205/files/l6data.rds?download=1"
    dest <- BiocFileCache::bfcrpath(BiocFileCache::BiocFileCache(ask = FALSE), url)
    
    mat <- readr::read_rds(dest)
    
    sdata <- CreateSeuratObject(counts = mat)
    
    embeddings <- as.matrix(cells[c("UMAP_1", "UMAP_2")])
    rownames(embeddings) <- cells$barcode
    
    umap_dr <- CreateDimReducObject(embeddings = embeddings, key = "UMAP_", assay = DefaultAssay(sdata))
    
    sdata[["umap"]] <- umap_dr
    
    Idents(sdata) <- setNames(cells$ident, cells$barcode)
    
    DimPlot(sdata, reduction = "umap", order = sort(unique(cells$ident), decreasing = TRUE), label = TRUE, alpha = .5)
    ```

**Tip:** The `cells` object here includes precomputed UMAP coordinates to save time. In a real-world workflow, you would extract cluster labels and embeddings from your processed Seurat/AnnData object and merge them with your immune receptor data for downstream analysis.

### How to read other types of data — bulk, single-chain, etc.

The `read_repertoires()` function is flexible and supports many repertoire data types and formats. Here are practical patterns for different scenarios. Use these examples as templates to adapt to your own data sources and formats.
*(These code blocks are for demonstration and not intended to run as part of this tutorial.)*

#### 1. Bulk sequencing

For bulk AIRR-seq data, you generally don’t need `barcode_col`, `locus_col`, or `umi_col`. Optionally provide `count_col` if your data includes receptor counts.

=== "R"  

    ```{r}
    #| label: load-dataset-types-bulk
    #| eval: false
    
    idata <- read_repertoires(path = inp_files, schema = schema, metadata = md_table, count_col = "counts", preprocess = make_default_preprocessing("airr"), repertoire_schema = "Tissue")
    ```

#### 2. Single-cell sequencing

For single-cell data, you’ll typically need all columns (barcode, locus, UMI) for proper chain aggregation and cell assignment.

=== "R"  

    ```{r}
    #| label: load-dataset-types-singlecell
    #| eval: false
    
    idata <- read_repertoires(path = inp_files, schema = schema, metadata = md_table, barcode_col = "barcode", locus_col = "locus", umi_col = "umis", preprocess = make_default_preprocessing("10x"), repertoire_schema = "Tissue")
    ```

#### 3. AIRR or 10x Genomics format

Both AIRR-C and 10x Genomics formats are supported. Pay attention to the locus column (`locus` or `chain`) and use the correct preset for `make_default_preprocessing()`.

=== "R"  

    ```{r}
    #| label: load-dataset-types-10x
    #| eval: false
    
    idata <- read_repertoires(path = inp_files, schema = schema, metadata = md_table, barcode_col = "barcode", locus_col = "locus", umi_col = "umis", preprocess = make_default_preprocessing("airr"), repertoire_schema = "Tissue")
    
    idata <- read_repertoires(path = inp_files, schema = schema, metadata = md_table, barcode_col = "barcode", locus_col = "chain", umi_col = "umis", preprocess = make_default_preprocessing("10x"), repertoire_schema = "Tissue")
    ```

#### 4. Reading file paths from metadata

If your metadata table contains file paths, you can use the special `path = "<metadata>"` argument. Specify which column in your metadata has the file paths with `metadata_file_col`.

=== "R"

    ```{r}
    #| label: load-dataset-types-meta
    #| eval: false
    
    idata <- read_repertoires(path = "<metadata>", schema = schema, metadata = md_table, barcode_col = "barcode", locus_col = "locus", umi_col = "umis", preprocess = make_default_preprocessing("10x"), repertoire_schema = "Tissue")
    ```

---

## Analyse immune repertoires - individually and in groups


### Explore key statistics of immune repertoires


#### Number of receptors and barcodes for samples

=== "R"

    ```{r}
    #| label: repertoire-stats-sample-plot
    #| eval: true
    #| fig-width: 11
    idata_stats <- airr_stats_chains(idata)
    
    idata_stats
    
    p1 <- ggplot(idata_stats, aes(x = Tissue, y = n_barcodes, fill = Tissue)) + geom_col() + ggtitle("No. barcodes per sample") + ggsci::scale_fill_locuszoom()
    p2 <- ggplot(idata_stats, aes(x = Tissue, y = n_receptors, fill = Tissue)) + geom_col() + ggtitle("No. receptors per sample") + ggsci::scale_fill_locuszoom()
    
    p1 + p2
    ```


#### Number of receptors and barcodes for cell clusters

Okay, that's great, but what if we want to have a detailed view on how clusters are represented? Currently, we have three repertoires in the `idata` coming from the different tissues:

=== "R"

    ```{r}
    #| label: repertoire-stats-show-repertoires
    #| eval: true
    
    idata$repertoires
    ```

Ideally, we want to explore each cell subpopulation in each tissue. For this, we will use powerful annotation mechanism from `immundata`. `idata` and `cells` have the same cell barcodes, so we can use them to annotate immune receptors with cluster label information, and then compute the same statistics on cluster level.

=== "R"

    ```{r}
    #| label: repertoire-stats-cluster
    #| eval: true
    #| cache: false
    
    annot <- tibble(Cluster = as.character(Idents(sdata)), barcode = names(Idents(sdata)))
    
    annot
    
    idata <- annotate_barcodes(idata, annot, "barcode")
    idata <- agg_repertoires(idata, c("Tissue", "Cluster"))
    
    idata$repertoires
    ```

And now, let's plot recompute statistics and plot them, but applied to "new" repertoires, which are now defined by a pair of columns - a tissue name "Tissue" and a cluster label "Cluster".

=== "R"

    ```{r}
    #| label: repertoire-stats-cluster-plot
    #| eval: true
    #| fig-width: 11
    idata_stats <- airr_stats_chains(idata)
    
    idata_stats
    
    p1 <- ggplot(idata_stats, aes(x = Tissue, y = n_barcodes, fill = Cluster)) + geom_col() + ggtitle("No. barcodes per sample")
    p2 <- ggplot(idata_stats, aes(x = Tissue, y = n_receptors, fill = Cluster)) + geom_col() + ggtitle("No. receptors per sample")
    
    p1 + p2
    ```

That's a lot of information! Let's group by cluster to understand the differences between tissues.

=== "R"

    ```{r}
    #| label: repertoire-stats-cluster-plot-patients
    #| eval: true
    #| fig-width: 11
    
    ggplot(idata_stats, aes(x = Cluster, y = n_receptors, fill = Tissue)) + geom_col(position = "dodge") + ggtitle("No. receptors per sample") + ggsci::scale_fill_locuszoom() + theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))
    ```

Lots of NAs. This is because we took only "TRB" chain, and the tumor receptors are going crazy, they have lots of receptors per one barcode.

If we reload the data with paired chain data, we will see another picture, as `immunarch` will filter out receptors additional receptors per barcode and leave only one pair per barcode. Do you want to do it? Consider this your homework! You just need to define a paired-chain schema for receptors (see one of the previous sections) and run pretty much the same code without any changes - that's the power of decoupling data processing to `immundata` and data analysis to `immunarch`. The latter pretty much doesn't care about the former, it just "asks" for receptors to exists - in any shape or form.

We see some expected yet interesting patterns like more Tregs in the tumor site or more Trm in the surrounding normal tissue. Our data is not normalized so we can't really compare how big is the difference. We will normalize the data by the overall number of receptors per sample, and then plot the same visualization.

=== "R"

    ```{r}
    #| label: repertoire-stats-cluster-plot-norm
    #| eval: true
    #| fig-width: 11
    
    idata_stats2 <- idata_stats |> mutate(.by = Tissue, TissueSize = sum(n_barcodes)) |> mutate(n_barcodes_div = n_barcodes / TissueSize)
    idata_stats2
    
    ggplot(idata_stats2, aes(x = Cluster, y = n_barcodes_div, fill = Tissue)) + geom_col(position = "dodge") + ggtitle("No. barcodes per sample") + ggsci::scale_fill_locuszoom() + theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))
    ```

#### Gene usage

=== "R"

    ```{r}
    #| label: repertoire-gene-usage-plot
    #| eval: true
    #| fig-width: 11
    
    # filter Trm and Treg
    # compute stats
    # join them
    # visualise
    airr_stats_genes(idata)
    ```


#### Length distribution


### Clonality

...


### Diversity

...


### Compute public receptor indices

...


#### Number of public receptors

...


#### Jaccard index

...


But what are those public receptors? The next section will help us extract them from the data.

---

## [WIP] Discover and annotate immune receptors

This section is under construction as I currently develop the receptor-level analysis functionality. I plan to release the most commonly used functions in October-November 2025. Monitor my [LinkedIn](https://www.linkedin.com/in/vdnaz) and [GitHub](https://github.com/immunomind/immunarch/issues/432) for news and updates.

The planned topics are:

- use external databases to find CMV-specific receptors in the input repertoires

- track specific CMV-related receptors through different tissues and highlight them on single-cell UMAP

- analyse and plot counts of specific receptors vs. expression of genes of interest

- public repertoire analysis - discover receptors which are suspiciously overabundant in one groups of repertoires in contrast to another groups of repertoires (e.g., control vs condition to search for TIL or antigen-specific receptors)

- all of above but using levenshtein-based similarity instead of exact matches

---

## [WIP] Analyse subgroups of receptors of interest

This is section is too under constructions. Planned content:

- discover receptors of interest, e.g., CMV-specific

- run analysis to compare sum/avg abundance of such receptors between groups to measure the level of signal

---

## [WIP] Conclusion

No spoilers. :-)

---

## Testing zone

Small test here and there, don't mind me, nothing suspicious is going on here...

=== "R"

    ```{r}
    #| eval: false
    c(1,2,3) |> sum()
    ```

=== "Python"

    ```{python}
    #| eval: false
    max([1,2,3])
    ```

Text block as a divider...

=== "R"

    ```{r}
    #| eval: true
    c(1,2,3) |> sum()
    ```

=== "Python"

    ```{python}
    #| eval: true
    max([1,2,3])
    ```
